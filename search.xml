<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ATX2入门进阶应用]]></title>
    <url>%2F2019%2F08%2F22%2FATX2%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 前言前面我们已经搭建好了ATX2平台来管理iOS设备，搭建博文参考:ATX2 iOS设备管理平台搭建 接下来分享一下该平台的入门进阶使用(还是基于iOS设备)。 ATX2入门操作 打开登录地址：http://172.28.xx.xx:4000/login 输入用户名登录ATX平台。 登录之后进入ATX2界面，在对应的设备点击点击使用则可以远程操作设备。 如下图所示，点击使用之后可以使用鼠标进行设备远程操作控制。 注意： iOS的弹窗不能通过屏幕点击来选择，需要在常用功能中点击“选择弹窗按钮”来进行操作 ATX2 APIATX2提供了API可以进行调用，可以方便我们在自动化测试过程中进行调用。API文档地址：https://github.com/openatx/atxserver2/blob/master/API.md 准备工作token获取ATX2所有的接口采用token认证，token可以在http://172.28.xx.xx:4000/user页面获取到也可以点击右上角用户名-&gt;用户信息获取，如下图所示: 获取设备的udid设备列表界面中的设备编号即为设备的udid,可以使用libimobiledevice命令获取设备的udid,命令如下： idevice_id -l # 显示当前所连接的设备[udid]，包括 usb、WiFi 连接c06e788b2d8dc60004a7015ce5dad782 API封装为了更好的调用API,我们可以进行封装方法，便于后续的调用。首先如下所示，我们定义一个类AtxiOS 这个类进行远程调用设备的初始化操作，如atx地址和token的初始化。 import json,loggingfrom urllib.parse import urljoinimport requestsfrom pprint import pprintlogging.basicConfig(level=logging.INFO, format='%(asctime)s %(filename)s[line:%(lineno)d]%(levelname)s%(message)s')DEVICES_URL = '/api/v1/devices' #获取全部设备信息USER_DEVICES_URL = '/api/v1/user/devices' #获取单台设备信息class AtxiOS(object): ''' 封装ATX2接口用于设备远程操作 ''' def __init__(self, atx_url, token): ''' 初始化操作 :param atx_url: atx的url地址 :param token: 账户的token ''' self.atx_url = atx_url self.token = token self.session = requests.Session() self.headers = dict(Authorization="Bearer &#123;&#125;".format(self.token)) self.apply_devices = &#123;&#125; def _get_response(self, url, method="GET", headers=None, data=None): """ 获取API响应结果 :param url:返回的url地址 :param method:请求方法 :param headers:响应header内容 :param data:响应的data内容 :return: 返回响应信息 """ if not headers: headers = self.headers try: response = self.session.request(method, url, headers=headers, data=data, timeout=20) info = response.json() except Exception as error: logging.error('网址：&#123;&#125;请求失败。&#123;&#125;'.format(url, error)) info = &#123;'success': False, 'description': 'Bad request url: &#123;&#125;'.format(url)&#125; return info 获取所有iOS设备信息在上面的AtxiOS类中定义如下方法用于获取所有iOS设备信息。 def get_all_iOS_devices(self): """ 获取所有iOS设备 :return: """ url = urljoin(self.atx_url, DEVICES_URL) info = self._get_response(url=url) pprint(info) return info 然后调用定义好的方法 ATX_URL ='http://172.28.xx.xx:4000'Token='xxxxxxxxx'udid='2cced5ac6ad06c35e067460dad5ff417f264b8ae' #iphone7 atx=AtxiOS(ATX_URL,Token)atx.get_all_iOS_devices() #获取所有设备信息 调用之后返回结果如下：&#123;'count': 4, 'devices': [&#123;'colding': False, 'createdAt': '2019-06-11T16:57:17.371000', 'owner': '', 'platform': 'apple', 'present': False, 'properties': &#123;'brand': 'Apple', 'name': '', 'product': 'Unknown'&#125;, 'udid': 'ece81864b51f3e0535bf86e9ab24f9209e9727f0', 'updatedAt': '2019-06-11T16:58:33.049000'&#125;, &#123;'colding': False, 'createdAt': '2019-06-11T10:17:43.340000', 'owner': '', 'platform': 'apple', 'present': False, 'properties': &#123;'brand': 'Apple', 'name': '', 'product': 'Unknown'&#125;, 'udid': '6dd5e55bf4204cd5ad8042dc4ecb2b703bbdb435', 'updatedAt': '2019-06-11T10:21:28.894000', 'using': False&#125;, &#123;'colding': False, 'createdAt': '2019-06-06T08:54:42.115000', 'idleTimeout': 600, 'lastActivatedAt': '2019-06-10T09:12:46.465000', 'owner': '', 'platform': 'apple', 'present': False, 'properties': &#123;'brand': 'Apple', 'ip': '172.28.212.16', 'name': 'iPhone6', 'product': 'iPhone 6', 'propertyId': '1908090114', 'sdkVersion': '12.2', 'version': '12.1.4'&#125;, 'udid': 'fa00fcc158dadb6bd1cc7c618540ebd7c3723520', 'updatedAt': '2019-06-10T10:13:48.662000', 'userId': None, 'using': False, 'usingBeganAt': '2019-06-10T09:02:10.333000', 'usingDuration': 1041.401&#125;, &#123;'colding': False, 'createdAt': '2019-05-30T21:39:47.708000', 'idleTimeout': 600, 'lastActivatedAt': '2019-06-11T16:53:32.250000', 'owner': '', 'platform': 'apple', 'present': True, 'properties': &#123;'brand': 'Apple', 'ip': '172.28.213.231', 'name': 'iPhone 7', 'product': 'iPhone 7', 'propertyId': '1908090112', 'sdkVersion': '12.2', 'version': '12.1.4'&#125;, 'udid': '2cced5ac6ad06c35e067460dad5ff417f264b8ae', 'updatedAt': '2019-06-11T16:53:56.737000', 'userId': None, 'using': False, 'usingBeganAt': '2019-06-11T16:53:32.250000', 'usingDuration': 8877.971&#125;], 'success': True&#125; 几个比较重要的字段说明 * platform目前有两个值android和apple * present代表设备是否在线 * colding代表设备是否正在清理或者自检中, 此时是不能占用设备的 * using代表设备是否有人正在使用 * userId代表使用者的ID，这里的ID其实就是Email * properties代表设备的一些状态信息，基本都是静态信息 获取单个设备信息如果我们想查看单个设备的信息，可以封装如下方法来查看。 def get_iOS_device_by_udid(self, udid): """ 获取单个设备信息 :param udid:str 设备的 udid 字段 :return: """ left_url = "/".join([USER_DEVICES_URL, udid]) url = urljoin(self.atx_url, left_url) info = self._get_response(url=url) # pprint(info) return info 调用方法如下： ATX_URL ='http://172.28.xx.xx:4000'Token='xxxxxxx'udid='2cced5ac6ad06c35e067460dad5ff417f264b8ae' #iphone7 atx=AtxiOS(ATX_URL,Token)device_info=atx.get_iOS_device_by_udid(udid) #获取单个设备信息pprint(device_info) 返回内容如下： &#123;'device': &#123;'colding': False, 'createdAt': '2019-05-30T21:39:47.708000', 'idleTimeout': 600, 'lastActivatedAt': '2019-06-11T16:53:32.250000', 'owner': '', 'platform': 'apple', 'properties': &#123;'brand': 'Apple', 'ip': '172.28.213.231', 'name': 'iPhone 7', 'product': 'iPhone 7', 'propertyId': '1908090112', 'sdkVersion': '12.2', 'version': '12.1.4'&#125;, 'source': &#123;'id': '0681c592-8bf4-11e9-afd1-0242ac120002', 'name': 'pyclient', 'owner': 'nobody@nobody.io', 'priority': 2, 'secret': '', 'url': 'http://172.28.xx.xx:3600', 'wdaUrl': 'http://172.28.xx.xx:20023'&#125;, 'sources': &#123;'0681c592-8bf4-11e9-afd1-0242ac120002': &#123;'id': '0681c592-8bf4-11e9-afd1-0242ac120002', 'name': 'pyclient', 'owner': 'nobody@nobody.io', 'priority': 2, 'secret': '', 'url': 'http://172.28.xx.xx:3600', 'wdaUrl': 'http://172.28.xx.xx:20023'&#125;&#125;, 'udid': '2cced5ac6ad06c35e067460dad5ff417f264b8ae', 'updatedAt': '2019-06-11T16:53:56.737000', 'userId': None, 'using': False, 'usingBeganAt': '2019-06-11T16:53:32.250000', 'usingDuration': 8877.971&#125;, 'success': True&#125; 获取设备远程WDA地址每台挂载在ATX2平台的iOS设备都有一个唯一的WDA地址，我们可以根据这个地址来远程调用该设备，一般地址格式为:ATX地址IP+端口号 def get_wda_url(self,udid): ''' 获取iOS设备远程wda链接 :param udid: 设备udid :return: ''' device_info =self.get_iOS_device_by_udid(udid) wda_url = device_info['device']['source']['wdaUrl'] logging.info('wda_url is %s' %wda_url) return wda_url 调用方法 ATX_URL ='http://172.28.xx.xx:4000'Token='a0344xxxxx45e92a396b0530'udid='2cced5ac6ad06c35e067460dad5ff417f264b8ae' #iphone7atx=AtxiOS(ATX_URL,Token)atx.get_wda_url(udid) #获取设备的远程url地址 返回结果 http://172.28.xx.xx:200000 设备占用 def using_iOS_device(self, udid): """ 占用一台设备 :param udid: str 设备的 udid 字段 :return: """ url = urljoin(self.atx_url, USER_DEVICES_URL) data = &#123;"udid": udid&#125; headers = self.headers headers["Content-Type"] = "application/json" info = self._get_response(url, "POST", headers, json.dumps(data)) logging.info(info) 调用方法 ATX_URL ='http://172.28.xx.xx:4000'Token='a0344xxxxx45e92a396b0530'udid='2cced5ac6ad06c35e067460dad5ff417f264b8ae' #iphone7 atx=AtxiOS(ATX_URL,Token)atx.using_iOS_device(udid) #占用设备 调用方法之后会有三种情况，设备占用成功或失败，返回内容如下： &#123;'description': 'Device successfully added', 'success': True&#125; #设备占用成功&#123;'description': 'Device add failed: device busy', 'success': False&#125; #设备被其他人占用&#123;'success': False, 'description': 'Device add failed: device not exist'&#125; #udid值错误 设备释放使用完设备之后我们需要释放设备，定义方法如下: def release_iOS_device(self, udid): """ 释放iOS设备 :param udid:str 设备的 udid 字段 :return: """ left_url = "/".join([USER_DEVICES_URL, udid]) url = urljoin(self.atx_url, left_url) info = self._get_response(url, "DELETE") logging.info(info) 调用方法如下： ATX_URL ='http://172.28.xx.xx:4000'Token='a0344xxxxx45e92a396b0530'udid='2cced5ac6ad06c35e067460dad5ff417f264b8ae' #iphone7 atx=AtxiOS(ATX_URL,Token)atx.release_iOS_device(udid) #释放设备 设备释放成功时返回内容如下： &#123;'success': True, 'description': 'Device successfully released'&#125; 注意：释放接口可以释放非当前账户占用的设备，释放时一定要确认udid是否为自己占用的设备，避免影响他人正常使用！]]></content>
      <categories>
        <category>App自动化</category>
      </categories>
      <tags>
        <tag>App自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS真机安装WebDriverAgent]]></title>
    <url>%2F2019%2F08%2F22%2FiOS%E7%9C%9F%E6%9C%BA%E5%AE%89%E8%A3%85WebDriverAgent%2F</url>
    <content type="text"><![CDATA[iOS 真机安装 WebDriverAgent本文根据 ATX 文档 - iOS 真机如何安装 WebDriverAgent 进行实践参考资料https://github.com/openatx/facebook-wdahttps://github.com/NetEaseGame/ATXhttps://github.com/facebook/WebDriverAgenthttps://github.com/appium/WebDriverAgent 准备工作注意：尽量升级Xcode到最新版本，iphone版本大于9.3 Xcode版本：10.2.1 iPhone版本：12.2 OS版本：10.14.4 实践开始 新建一个目录，从 git 下载 WDA 项目代码到本地 git clone https://github.com/facebook/WebDriverAgent 运行初始化脚本 #进入代码目录cd xx/xx/WebDriverAgent-master#执行初始化脚本./Scripts/bootstrap.sh 注 根据报错通过 brew 安装以下依赖 carthage依赖：brew install carthage npm：brew install npm 证书设置 进入项目路径，双击打开WebDriverAgent.xcodeproj，打开xcode后按照下方数字序号依次点击，勾选第5项目，弹框内点击Enable Automatic。 Team 栏添加帐户（个人账号和开发者账号兼可）选中 接着在TARGETS里面选中WebDriverAgentRunner，用同样的方法设置好证书 个人免费版的证书，还需要修改下WebDriverAgent的BundleID，随便加后缀，不要跟别人重复就好 运行和测试 点击方框选项，分别选择WebDriverAgentRunner和目标设备 运行 Product -&gt; Test一切正常的话，手机上会出现一个无图标的WebDriverAgent应用，启动之后，马上又返回到桌面。 个人免费证书第一次运行需要信任证书日志信息如下： Verify the Developer App certificate for your account is trusted on your device. Open Settings on Vic小叶子 and navigate to General -&gt; Device Management, then select your Developer App certificate to trust it. 原因：开发者人员程序未受信任解决：进入手机设置-&gt; 通用-&gt; 描述文件与设备管理-&gt; 点击开发者应用，信任一下就好了。 此时控制台界面可以看到设备的IP。如果看不到的话，使用这种方法打开 通过上面给出的IP和端口，加上/status合成一个url地址。例如http://10.0.0.1:8100/status，然后浏览器打开。如果出现一串JSON输出，说明WDA安装成功了。 实际情况，我到这一步访问这个地址无响应： 原因：部分国行的iphone机器通过IP和端口还不能访问 解决：需要将手机的端口转发到Mac上（端口转发见下文） 端口转发有些国产的iPhone机器通过手机的IP和端口还不能访问，此时需要将手机的端口转发到Mac上。 安装libimobiledevice brew updatebrew uninstall --ignore-dependencies libimobiledevicebrew uninstall --ignore-dependencies usbmuxdbrew install --HEAD usbmuxdbrew unlink usbmuxdbrew link usbmuxdbrew install --HEAD libimobiledevice 转发端口iproxy 8100 8100 UDID使用iproxy –help 可以查到更具体的用法。 查询UDIDinstruments -s 这时通过访问http://localhost:8100/status，如果出现一串JSON输出，说明WDA安装成功了。 inspector是用来查看UI的图层，方便编写测试脚本inspector的地址是:http://localhost:8100/inspector 使用终端替代Xcode通常来说为了持续集成，能够全部自动化比较好一些启动 WebDriverAgent，官方提供了四种方式： Xcode xcodebuild Using fbsimctl from FBSimulatorControl framework Using FBSimulatorControl framework directly # 解锁keychain，以便可以正常的签名应用，PASSWORD="replace-with-your-password"security unlock-keychain -p $PASSWORD ~/Library/Keychains/login.keychain# 获取设备的UDIDUDID=$(idevice_id -l | head -n1)# 运行测试xcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination "id=$UDID" test]]></content>
      <categories>
        <category>App自动化</category>
      </categories>
      <tags>
        <tag>App自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装]]></title>
    <url>%2F2019%2F08%2F21%2FDocker%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[atxserver2设备管理平台搭建]]></title>
    <url>%2F2019%2F08%2F21%2Fatxserver2%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[[TOC] 前言前面分享了STF Andriod设备远程管理平台的搭建和使用，但是STF不支持iOS设备连接，虽然现在社区有了STF集成iOS设备的开源方案，但是经过实践不太稳定，后面再Testerhome社区发现了一个新的框架ATX2同时支持Android和iOS设备远程管理，经过实践设备连接非常稳定，所以这里分享下这个平台的搭建和使用 ATX2简介ATX2是一款可以远程控制Android和iOS设备的设备管理平台。该平台使用的技术栈为:Python3+NodeJS+RethinkDB 项目目前已经开源，作者是阿里的一位大牛:codeskyblue 项目:Github地址:https://github.com/openatx/atxserver2 平台框架图如下所示： 环境准备系统环境:Mac Os 10.14.6(因为要使用iOS设备连接WDA，所以需要Mac Os环境) python3安装brew install python3 rethinkdb安装brew install rethinkdb 服务部署启动ATX2服务有2种方式： Docker部署 源码部署 Docker部署 使用Docker部署需要安装Docker，具体安装步骤见:Docker安装 代码Clone到本地 git clone https://github.com/openatx/atxserver2 打开命令终端，切换到代码目录，执行一条命令即可 docker-compose up 源码部署先准备好一个rethinkdb服务器，并启动rethinkdb 代码clone到本地git clone git@github.com:openatx/atxserver2.git 打开命令终端，切换到代码目录，然后执行命令下面的命令安装依赖pip3 install -r requirements.txt 启动服务，命令如下#默认方式启动，使用默认的登录方式，默认端口python3 main.py # 指定认证方式python3 main.py --auth simple #默认是一个非常simple的认证，输入邮箱就可以# 设置监听端口python3 main.py --port 4000 # 默认监听4000端口 打开页面启动之后，浏览器打开http://localhost(本机ip也可以):4000，登录之后就可以顺利的看到设备列表页了,由于还没有接入设备所以设备列表为空。 Android设备接入atxserver2-android-provider依赖 Python3.6+, NodeJS 8, Git-LFSNodeJS版本太高了也不行，一定要NodeJS 8，推荐使用nvm管理node版本 Install git-lfsbrew install git-lfs Clone代码到本地，切换到代码目录git clone https://github.com/openatx/atxserver2-android-providercd atxserver2-android-providergit lfs installgit lfs pull 安装依赖npm installpip install -r requirements.txt 启动，需要指定atxserver2的地址, 假设地址为 http://localhost:4000python3 main.py --server localhost:4000 Provider可以通过adb track-devices自动发现已经接入的设备，当手机接入到电脑上时，会自动给手机安装minicap, minitouch, atx-agent, app-uiautomator-[test].apk, whatsinput-apk 接入的设备需要配置好开发者选项, 不同设备的设置方案放到了该项目的Issue中, tag: device-settings 如果没有该机型，可以自助添加 iOS设备接入atxserver2-ios-provider依赖 Python3.6+, NodeJS 8, WebDriverAgent(appium) 安装libimobiledevice工具包 brew uninstall --ignore-dependencies libimobiledevicebrew uninstall --ignore-dependencies usbmuxdbrew install --HEAD usbmuxdbrew unlink usbmuxdbrew link usbmuxdbrew install --HEAD libimobiledevicebrew install ideviceinstallerbrew link --overwrite ideviceinstaller 安装atxserver2-ios-provider,git clone https://github.com/openatx/atxserver2-ios-provider --recursivecd atxserver2-ios-providerpip3 install -r requirements.txtnpm install 初始化其中的ATX-WebDriverAgentgit clone https://github.com/appium/WebDriverAgentcd ATX-WebDriverAgentbrew install carthage./Scripts/bootstrap.sh 后找台手机接到苹果电脑上。 按照这个文档https://testerhome.com/topics/7220 对WebDriverAgent项目进行下设置 启动python3 main.py 连接成功后，如下图所示可以看到连接的iOS设备，点击立即使用即可远程控制。]]></content>
      <categories>
        <category>App自动化</category>
      </categories>
      <tags>
        <tag>App自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods安装]]></title>
    <url>%2F2019%2F08%2F21%2FCocoaPods%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ruby环境搭建查看当前Ruby版本ruby -v 查看rvm版本rvm -v 显示如下(或者是其他版本) rvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io] 列出ruby可安装的版本信息rvm list known 显示如下 # MRI Rubies[ruby-]1.8.6[-p420][ruby-]1.8.7[-head] # security released on head[ruby-]1.9.1[-p431][ruby-]1.9.2[-p330][ruby-]1.9.3[-p551][ruby-]2.0.0[-p648][ruby-]2.1[.10][ruby-]2.2[.10][ruby-]2.3[.7][ruby-]2.4[.4][ruby-]2.5[.1] // 重点在这里 重点在这里 重点在这里[ruby-]2.6[.0-preview2] // 测试版ruby-head..... 安装一个ruby版本（这里我选择的是2.5.1版本，当然你也可以选择其他的）rvm install 2.5.1// 注意:安装过程中需要两次按下 Enter 键, 第二次按下后需要输入电脑访问密码(不可见,只管输入就行);// 如果你电脑没有安装Xcode和Command Line Tools for Xcode以及Homebrew 会自动下载安装,建议提前安装这三者. 这里很多小伙伴会遇到错误，大部分是因为没有安装Homebrew造成，所以所以所以要提前安装比较好 /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 设置为默认版本rvm use 2.5.1 --default 更换源sudo gem update --systemgem sources --remove https://rubygems.org/gem sources --add https://gems.ruby-china.com/ 为了验证你的Ruby镜像是并且仅是ruby-china，执行以下命令查看gem sources -l 如果是以下结果说明正确，如果有其他的请自行百度解决 *** CURRENT SOURCES ***https://gems.ruby-china.com/ 开始安装CocoaPodssudo gem install -n /usr/local/bin cocoapods 如果安装了多个Xcode使用下面的命令选择（一般需要选择最近的Xcode版本）sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer 安装本地库pod setup 执行以上命令后Setting up CocoaPods master repo $ /usr/bin/git clone https://github.com/CocoaPods/Specs.git master --progress Cloning into 'master'... remote: Counting objects: 1879515, done. remote: Compressing objects: 100% (321/321), done. Receiving objects: 21% (404525/1879515), 73.70 MiB | 22.00 KiB/ 然后就是漫长的等待，当然,网络好的情况下会更快 如果一直安装不成功请参考这里 查看你是否安裝成功pod 显示Usage: $ pod COMMAND CocoaPods, the Cocoa library package manager.Commands: + cache Manipulate the CocoaPods cache + deintegrate Deintegrate CocoaPods from your project + env Display pod environment + init Generate a Podfile for the current directory + install Install project dependencies according to versions from a Podfile.lock + ipc Inter-process communication + lib Develop pods + list List pods + outdated Show outdated project dependencies + plugins Show available CocoaPods plugins + repo Manage spec-repositories + search Search for pods + setup Setup the CocoaPods environment + spec Manage pod specs + trunk Interact with the CocoaPods API (e.g. publishing new specs) + try Try a Pod! + update Update outdated project dependencies and create new Podfile.lockOptions: --silent Show nothing --version Show the version of the tool --verbose Show more debugging information --no-ansi Show output without ANSI codes --help Show help banner of specified command CocoaPods版本pod --version]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端安装指定版本node]]></title>
    <url>%2F2019%2F08%2F21%2FMac%E7%BB%88%E7%AB%AF%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACnode%2F</url>
    <content type="text"><![CDATA[安装brew终端上运行/usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 安装NVMbrew install nvm 安装完成之后打开shell的配置文件cd ~vim .bash_profile 在文件里添加以下命令export NVM_DIR=~/.nvmsource $(brew --prefix nvm)/nvm.sh 然后重新sourcesource .bash_profile 使用nvm安装nodenvm ls-remote 查看 所有的node可用版本nvm install xxx 下载你想要的版本nvm use xxx 使用指定版本的nodenvm alias default xxx 每次启动终端都使用该版本的node]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS环境搭建STF]]></title>
    <url>%2F2019%2F08%2F21%2FMac%20OS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BASTF%2F</url>
    <content type="text"><![CDATA[前言STF（Smartphone Test Farm）是一个Web应用程序，用于从浏览器中远程调试智能手机，智能手表和其他小工具。openstf GitHub开源地址 功能： 支持的系统：Android 版本限制：2.3.3 (SDK 版本 10) to 9.0 (SDK 版本 28) Android Wear 5.1（由于权限问题不支持5.0） Fire OS, CyanogenMod，基于Android的发行版 当前任何功能都不需要root 从浏览器远程控制任何设备 管理所有挂机设备 环境搭建需要使用到的工具或环境 Node.js &gt;= 6.9 (首选最新稳定版) ADB RethinkDB &gt;= 2.2 GraphicsMagick (用来调整屏幕截图的大小) ZeroMQ 自带安装，无需另行安装 Protocol Buffers 自带安装，无需另行安装 yasm 自带安装，无需另行安装 (为了编译 libjpeg-turbo) pkg-config 安装后Node.js就可以找到自带库 通过brew安装依赖在终端使用输入命令安装所需的依赖：brew install rethinkdb graphicsmagick zeromq protobuf yasm pkg-config 若提示找不到brew，则需要先安装brew，参照：Homebrew Node.js安装Node.js版本强烈建议选择8.X 版本,如果是安装了最新10.X及以上版本后续安装stf过程中可能会出现报错，参考Mac终端安装指定版本nodenode -v v8.16.0npm -v 6.4.1 由于网络限制，为了保障后续安装顺利，这里我们建议增加 npm淘宝镜像。npm install -g cnpm --registry=https://registry.npm.taobao.org adb安装使用brew安装，命令如下:brew cask install android-platform-tools 安装完成后，连上Android 设备(开启usb-debug)输入命令adb –version查看是否安装成功。adb --version Android Debug Bridge version 1.0.41 Version 29.0.1-5644136 Installed as /usr/local/bin/adb stf安装这里我们使用上面安装的cnpm来安装npm install -g stf 安装完成后使用命令stf doctor检查相关依赖是否安装正常。stfs-Mac-mini:~ stf$ stf doctor2019-08-01T05:17:19.556Z INF/cli:doctor 58578 [*] OS Arch: x642019-08-01T05:17:19.558Z INF/cli:doctor 58578 [*] OS Platform: darwin2019-08-01T05:17:19.558Z INF/cli:doctor 58578 [*] OS Platform: 18.0.02019-08-01T05:17:19.558Z INF/cli:doctor 58578 [*] Using Node 8.16.02019-08-01T05:17:19.572Z INF/cli:doctor 58578 [*] Using ZeroMQ 4.3.22019-08-01T05:17:19.581Z INF/cli:doctor 58578 [*] Using GraphicsMagick 1.3.332019-08-01T05:17:19.582Z INF/cli:doctor 58578 [*] Using ADB 1.0.412019-08-01T05:17:19.587Z INF/cli:doctor 58578 [*] Using RethinkDB 2.3.62019-08-01T05:17:19.589Z INF/cli:doctor 58578 [*] Using ProtoBuf 3.7.1 如果安装过程中出现如下错误，说明Node版本不兼容。 make: *** [Release/obj.target/bufferutil/src/bufferutil.o] Error 1gyp ERR! build error gyp ERR! stack Error: `make` failed with exit code: 2gyp ERR! stack at ChildProcess.onExit (/usr/local/lib/node_modules/cnpm/node_modules/node-gyp/lib/build.js:262:23)gyp ERR! stack at ChildProcess.emit (events.js:198:13)gyp ERR! stack at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12)gyp ERR! System Darwin 18.0.0gyp ERR! command "/usr/local/bin/node" "/usr/local/lib/node_modules/cnpm/node_modules/npminstall/node-gyp-bin/node-gyp.js" "rebuild"gyp ERR! cwd /usr/local/lib/node_modules/stf/node_modules/_bufferutil@1.3.0@bufferutilgyp ERR! node -v v10.16.1gyp ERR! node-gyp -v v3.8.0gyp ERR! not ok [npminstall:runscript:error] bufferutil@^1.2.1 has binding.gyp file, run "node-gyp rebuild" error: RunScriptError: Run "sh -c node-gyp rebuild" error, exit code 1Install fail! RunScriptError: Run "sh -c node-gyp rebuild" error, exit code 1RunScriptError: Run "sh -c node-gyp rebuild" error, exit code 1 at ChildProcess.proc.on.code (/usr/local/lib/node_modules/cnpm/node_modules/runscript/index.js:96:21) at ChildProcess.emit (events.js:198:13) at maybeClose (internal/child_process.js:982:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:259:5)npminstall version: 3.22.1npminstall args: /usr/local/bin/node /usr/local/lib/node_modules/cnpm/node_modules/npminstall/bin/install.js --fix-bug-versions --china --userconfig=/Users/stf/.cnpmrc --disturl=https://npm.taobao.org/mirrors/node --registry=https://r.npm.taobao.org -g stf --unsafe-perm 解决方案:使用如下命令卸载Node，然后安装8.X版本的Node。 启动服务启动rethinkdbstf使用的是RethinkDB数据库，所以在启动stf前需要先启动RethinkDB，启动RethinkDB很简单，只需要执行以下命令：rethinkdb 因为默认端口是8080，我已经有其他服务被占用，所以另开一个端口rethinkdb --bind all --cache-size 8192 --http-port 9090 –cache-size指定缓存大小–http-port 指定端口 启动stf另开一个终端，执行stf local 如果想让其他机器连接到stf需要加上 –public-ipstf local --public-ip &lt;本机的IP地址&gt; 最后输入http://localhost:7100或者 http://&lt;ip地址&gt;:7100即可访问stf地址，界面如下: 输入用户名和邮箱即可登录，用户名和邮箱可以随便填写。USB链接Android设备，开发者模式打开USB调试，就可以看到设备了]]></content>
      <categories>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>设备管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章加密]]></title>
    <url>%2F2019%2F05%2F27%2FHexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[hexo-blog-encrypt插件GitHub官网 安装博客根目录下运行以下命令 npm install --save hexo-blog-encrypt 设置首先在 站点配置文件 中启用该插件:encrypt: enable: true ##然后在你的文章的头部添加上对应的字段，如 password, abstract, message ---title: 文章加密date: 2019-01-04T22:20:13.000Zcategory: 教程tags: - 博客 - Hexokeywords: 博客文章密码password: TloveYabstract: 密码：TloveYmessage: 输入密码，查看文章--- password: 是该博客加密使用的密码 abstract: 是该博客的摘要，会显示在博客的列表页 message: 这个是博客查看时，密码输入框上面的描述性文字 如果你想对 TOC 也进行加密，则在 article.ejs 中将 TOC 的生成代码修改成如下：&lt;% if(post.toc == true)&#123; %&gt; &lt;div id="toc-div" class="toc-article" &lt;% if (post.encrypt == true) &#123; %&gt;style="display:none" &lt;% &#125; %&gt;&gt; &lt;strong class="toc-title"&gt;Index&lt;/strong&gt; &lt;% if (post.encrypt == true) &#123; %&gt; &lt;%- toc(post.origin) %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- toc(post.content) %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;%- post.content %&gt; 自定义如果你对默认的主题不满意，或者希望修改默认的提示和摘要内容，你可以添加如下配置在 站点配置文件 中。encrypt: enable: true default_abstract: 这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与我联系。 default_message: 输入密码，查看文章。 这样，对于每一篇需要加密的文章就不必都在在头部添加 abstract 和 message 字段了，脚本会自动添加默认的内容填充。 如果你希望对某一篇特定的文章做特殊处理（如本文的 abstract ，可以在对应文章的头部添加---title: 文章加密date: 2019-01-04T22:20:13.000Zcategory: 教程tags: - 博客 - Hexokeywords: 博客文章密码password: TloveYabstract: 密码：TloveY--- 此时，博客头部的 abstract 会覆盖 站点配置文件 的 default_abstract 实现自定义。 存在问题 如果你开启了 字数统计功能 的话，那么本文的字数会显得比实际值大。 加密文章内部分脚本会失效，已知 代码复制 失效。]]></content>
      <categories>
        <category>Hexo Next</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之添加萌萌哒]]></title>
    <url>%2F2019%2F05%2F26%2FHexo%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%90%8C%E8%90%8C%E5%93%92%2F</url>
    <content type="text"><![CDATA[安装插件npm install --save hexo-helper-live2d 复制你喜欢的模型名字：hijiki Epsilon2.1Gantzert_Felixandeharuharutohibikihijikikoharumikuni-jniconietzchenipsilonnitoshizukutororotsumikiUnitychanwankoz16 将以下代码添加到主题配置文件_config.yml，修改&lt;你喜欢的模型名字&gt;：live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true 建配置文件 在站点目录下建文件夹live2d_models， 再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;, 再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json 安装模型。在命令行（即Git Bash）运行以下命令即可：npm install –save live2d-widget-model-&lt;你喜欢的模型名字&gt;]]></content>
      <categories>
        <category>Hexo Next</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 代码块复制功能]]></title>
    <url>%2F2019%2F05%2F26%2FHexo%20NexT%20%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言为了提高博客代码块的用户体验，仅仅代码高亮还不行，最好还能一键复制代码。故此文将讲述Hexo NexT主题博客的代码块复制功能配置。 下载clipboard.js三方插件 clipboardjs ，相关介绍和兼容性我就不赘述了，去它主页或github上看。 下载地址： clipboard.js clipboard.min.js保存文件clipboard.js、clipboard.min.js，到目录\themes\next\source\js\src下 clipboardjs 使用在\themes\next\source\js\src目录下，创建clipboard-use.js文件，文件内容如下： /*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; copyHtml += ' &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode();&#125;(window, document); 在.\themes\next\source\css\_custom\custom.styl文件中添加下面代码： //代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 引用在.\themes\next\layout\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（）之前添加）： &lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/clipboard.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/clipboard-use.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>Hexo Next</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之Next主题美化]]></title>
    <url>%2F2019%2F05%2F25%2FHexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E4%B9%8BNext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言有了前面几篇博客的介绍，我们就可以很容易的搭建我们的博客了，不过既然是属于自己的博客网站，自然也就想让其更加美观，更有意思，所以呢我下面介绍一下Hexo博客的主题美化操作。 Hexo博客支持很多主题风格，其中Next主题是Github上Star最多的主题，其一直在更新维护，支持非常多的外部插件和功能选项。我目前使用的是NexT.Gemini v7.1.1版本，下面我会介绍基于Next7主题的界面美化。 命名在Hexo中有2份主要的配置文件，其名称都是_config.yml。 其中，一份位于博客根目录下，主要包含 Hexo 本身的配置；另一份位于themes/next/目录下，用于配置主题相关的选项。 博客配置文件：博客根目录下_config.yml 主题配置文件：themes/next/目录下_config.yml 基础设置##设置站点名、作者昵称和站点描述等内容打开博客配置文件，博客根目录下_config.yml # Sitetitle: Vicの博客subtitle: 测试攻城狮description: 人生苦短，我学Pythonkeywords:author: Viclanguage: zh-CNtimezone: Asia/Shanghai Next主题的安装配置Next主题的安装方式很简单，只需要在博客根目录下执行： git clone https://github.com/theme-next/hexo-theme-next themes/next 然后设置博客配置文件_config.yml：（博客根目录下的_config.yml） theme: next 即可将我们的Hexo博客主题替换为Next主题。 主题配置Next主题风格打开themes/next/下的_config.yml，查找scheme，可以看到如下四种不同的风格方案： #scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 去掉#注释，即启用对应的scheme，博主采用Gemini主题。 设置菜单及对应页面 打开themes/next/下的_config.yml，查找menu menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat favorite: /favorite/ || fa-star 去掉#注释即可显示对应的菜单项，也可自定义新的菜单项。||之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。 例如上面添加：favorite: /favorite/ || fa-star 新建一个页面，命名为 categories hexo new page "favorite" 此时在根目录的source文件夹下会生成一个favorite文件夹，文件中有一个index.md文件，文件内容修改增加 type 属性 ---title: Favoritedate: 2019-05-20 19:11:41type: "favorite"--- 新添加的菜单需要翻译对应的中文 打开hexo/theme/next/languages/zh-CN.yml，在menu下自定义，如： menu: favorite: 收藏夹 一般配置 Next主题一般配置： override：false #表示是否将主题置为默认样式cache: enable:true #表示添加缓存功能，这样浏览器后续打开我们的博客网站会更快menu: #设置博客各个页面的相对路径，默认根路径是blog/source home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #日历 #sitemap: /sitemap.xml || sitemap #站点地图，供搜索引擎爬取 #commonweal: /404/ || heartbeat # 腾讯公益404# Enable/Disable menu icons / item badges.menu_settings: icons: true # 是否显示各个页面的图标 badges: true # 是否显示分类/标签/归档页的内容量# Schemesscheme: Gemini 站点配置MyBlog/_config.yml文件的基本配置为 # Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Vicの博客 # 网站标题subtitle: 测试攻城狮 # 网站子标题description: 人生苦短，我学Python # 网站描述keywords:author: Vic # 网站作者，也就是您的名字language: zh-CN # 网站使用的语言timezone: Asia/Shanghai # 网站时区。Hexo 预设使用您电脑的时区。# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://vic.kimroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: source # 资源文件夹，这个文件夹用来存放内容，例如我们用markdown编写的博文public_dir: public # 公共文件夹，这个文件夹用于存放生成的静态博客文件。tag_dir: tags # 标签文件夹archive_dir: archives # 归档文件夹category_dir: categories # 分类文件夹code_dir: downloads/code # Include code 文件夹i18n_dir: :lang # 国际化（i18n）文件夹skip_render: # 跳过指定文件的渲染，您可使用 glob 来配置路径。# Searchsearch: path: search.xml # 索引文件的路径，相对于站点根目录 field: post # 搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面 format: html limit: 10000 # 限制搜索的条目数# Writingnew_post_name: :title.md # 默认的新博文名称default_layout: post # 默认布局titlecase: false # 把标题转换为 titlecase（titlecase指的是将每个单词首字母转换成大写）external_link: true # 在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写, 0表示不变render_drafts: false # 是否显示草稿post_asset_folder: true #是否启用资源文件夹（用来存放相对路径图片或文件）relative_link: false # 把链接改为与根目录的相对位址future: truehighlight: enable: true #是否开启代码高亮 line_number: false #是否增加代码行号 auto_detect: false #自动判断代码语言 tab_replace:# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' #博客的默认路径 per_page: 10 #每页博客数量上限 order_by: -date #博客排序# Category &amp; Tagdefault_category: uncategorized # 默认分类, uncategorized表示未分类category_map: # 分类别名tag_map: # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #博客日期格式time_format: HH:mm:ss #博客时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页显示的文章量，如果设置值为0，则表示禁止分页pagination_dir: page # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next #选择博客主题，名字为themes中选择的主题文件夹名称# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/HappyVic/HappyVic.github.io branch: master# hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica textColor: '#333' textHeight: 25 outlineColor: '#E2E1D1' maxSpeed: 0.1 美化设置头像找自己喜欢的图，放至themes/next/source/images/文件夹下打开themes/next/下的_config.yml，查找Sidebar Avatar。修改url的值 # Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifurl: /images/smile.jpg url的值是图片的链接地址 网站图标设置我们博客的默认图标是H，不过Next支持修改图标 图标素材网站：easyicon、iconfont 下载16x16以及32x32大小的PNG格式图标，置于/themes/next/source/images/下 打开themes/next/下的_config.yml，查找favicon favicon: small: /images/cat-16x16-next.png medium: /images/cat-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 修改small和medium的路径为下载的图标路径 鼠标点击特效 鼠标点击红心特效 在/themes/next/source/js/src下新建文件 clicklove.js，接着把下面的代码拷贝粘贴到clicklove.js文件中： !function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\next\layout\_layout.swig文件末尾添加： &lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 爆炸红心特效（比较花里胡哨不推荐）在themes/next/source/js/src里面建一个fireworks.js的文件，接着把下面的代码拷贝粘贴到fireworks.js文件中： "use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码：（注意和上面的对其） &#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在文件末尾添加：（themes/next/下的_config.yml） # Fireworksfireworks: true 背景动画（只能选一个）Canvas-nest风格、JavaScript 3D library风格 动画只能选一个 Canvas-nest风格 进入theme/next目录，执行以下命令 git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 打开themes/next/下的_config.yml文件，搜索Canvas-nest，将canvas_nest的中enable值改为true即可 # Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: "0,0,255" # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines JavaScript 3D library风格 进入theme/next目录，执行以下命令 git clone https://github.com/theme-next/theme-next-three source/lib/three 打开themes/next/下的_config.yml文件，搜索theme-next-three，将想要的效果改为true即可： # three_wavesthree_waves: false# canvas_linescanvas_lines: true# canvas_spherecanvas_sphere: false 设置侧栏在左侧/右侧打开themes/next/下的_config.yml，查找sidebar Pisces或Gemini方案 打开themes/next/下的_config.yml，查找sidebar，将想要的方案打开 sidebar:position: left#position: right Mist或Muse方案 打开next/source/js/src/motion.js，查找paddingRight，把所有（2个）PaddingRight更改为paddingLeft即可。 打开next/source/css/_custom/custom.styl，添加如下内容： //侧边栏置于左侧.sidebar &#123; left: 0;&#125;//侧栏开关置于左侧.sidebar-toggle &#123; left: $b2t-position-right;&#125; 打开next/source/css/_common/components/back-to-top.styl，将right: $b2t-position-right;改为left: $b2t-position-right; 显示侧边栏的时机打开themes/next/下的_config.yml，查找sidebar # Sidebar Display, available values (only for Muse | Mist):# - post expand on posts automatically. Default.# - always expand for all pages automatically.# - hide expand only when click on the sidebar toggle icon.# - remove totally remove sidebar including sidebar toggle.display: post 文章末尾添加版权声明打开themes/next/下的_config.yml，查找creative_commons creative_commons: license: by-nc-sa sidebar: false post: true # 将false改为true即可显示版权信息 language: 添加本地搜索功能参考文章Hexo Next 主题中添加本地搜索功能 建立标签云及效果展示参考文章Hexo博客建立标签云及效果展示 文章添加阴影、透明效果打开theme/next/source/css/_custom/custom.styl，添加以下代码 // 主页文章添加阴影效果.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; background:rgba(255,255,255,0.9) none repeat scroll !important; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 设置代码块样式在博客配置文件中，搜索highlight: highlight: enable: true #是否开启代码高亮 line_number: false #是否增加代码行号 auto_detect: true #自动判断代码语言 tab_replace: 代码块背景。打开themes/next/下的_config.yml，查找highlight_theme # Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties 代码块复制功能参考文章Hexo NexT 代码块复制功能 显示当前浏览进度打开themes/next/下的_config.yml，查找back2top back2top: enable: true # Back to top in sidebar. sidebar: true # Scroll percent label in b2t button. scrollpercent: true 在右上角或者左上角实现fork me on github 选择样式GitHub Ribbons, 修改图片跳转链接,将中的链接换为自己Github链接： 打开 themes/next/layout/_layout.swig 文件，把代码复制到下面。]]></content>
      <categories>
        <category>Hexo Next</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用Hexo+Github搭建个人博客]]></title>
    <url>%2F2019%2F05%2F25%2FMac%E4%B8%8B%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言Hexo是一个快速、简洁且高效的博客框架，最近有搭建个人博客的想法，便动手尝试了。官方的文档 hexo博客系统搭建Github账号注册及仓库创建 进入Github官网，注册账号 注册成功点击new仓库 创建仓库的名字必须为username.github.io，我的用户名为Vicxiaoyezi，因此我创建的仓库就是Vicxiaoyezi.github.io，这是很关键的一点，很重要。输入名字后，直接点最下面绿色的按钮“Create repository”，创建新仓库。这一部分基本完成了，接下去需要在终端操作。 安装Node.js 首先检查是否安装了node.js node -v # 是否出现安装版本信息，出现说明已经安装了 如果未安装，去Node.js官网下载相应的安装包，一路安装即可。 #安装完成之后打开终端，分别输入一下命令，如果出现版本信息，就说明安装成功。node-v npm -v 安装GitMac下安装Xcode就自带Git。 首先检查是否安装了Git git --version # 是否出现安装版本信息，出现说明已经安装了 未安装通过Homebrew安装git（Homebrew的安装参考），终端命令输入 brew install git 配置SSH Key这一步不是必须的，配置SSH Key的话之后每次更新博客就不用都输入用户名和密码，可以方便一些。配置参考Mac下配置SSH key 安装Hexo 安装hexo 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 npm install -g hexo-cli 创建博客目录 在任意位置创建一个文件夹，如MyBlog，cd到该路径下 # 在你选择的目录下创建一个MyBlog文件夹mkdir MyBlog# 进入目录cd MyBlog 初始化目录，在MyBlog目录下 hexo init 启动本地服务 hexo s # 也可是 hexo server 如果出现以下信息说明成功，浏览器输入http://localhost:4000/ 就可以访问了。 当然这个博客是本地的，别人是无法访问的，之后我们需要部署到GitHub上。 INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 博客关联到Github仓库博客文件夹MyBlog中的_config.yml文件，这是博客的主要配置文件。 编辑博客配置文件_config.yml中的deploy节点。记得将username（Vicxiaoyezi）换成自己的username deploy: type: git repo: git@github.com:Vicxiaoyezi/Vicxiaoyezi.github.io.git branch: master 注意：repo为这种形式的是配置了SSH Key之后的，如果没有配置则使用Https形式的地址。 为了能够使Hexo部署到GitHub上，需要安装一个插件，在博客目录下运行以下命令 npm install hexo-deployer-git --save 然后在博客目录中执行 #清除缓存hexo clean# 产生静态网页hexo g# 部署到GitHub page上hexo d 在浏览器输入username.github.io就可以访问你的博客了(例如：Vicxiaoyezi.github.io)。 博客的基本使用 创建新文章，博客目录下执行以下命令 hexo new '文章标题'#例如：hexo new Mac下使用Hexo-Github搭建个人博客 这样会在本地博客的source-&gt;_posts路径下看到新建的文章，是md格式的，找一个markdown文本编辑器进行编辑即可。 编辑完成之后本地地址预览，在博客目录下运行以下命令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 编辑完成之后上传Github，在博客目录下运行以下命令 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d Hexo博客美化及功能增添Hexo官网主题Hexo主题在Github上有很多，如 https://github.com/theme-next/hexo-theme-nexthttps://github.com/litten/hexo-theme-yiliahttps://github.com/viosey/hexo-theme-materialhttps://github.com/LouisBarranqueiro/hexo-theme-tranquilpeakhttps://github.com/pinggod/hexo-theme-apollohttps://github.com/ppoffice/hexo-theme-icarus 挑选自己喜欢的一款。当然自己能够DIY，但是路很长慢慢来。 绑定个人域名如果你想拥有一个炫酷的域名，那就往下看吧 购买域名可以去万网买，也可以去其它地方。具体购买过程就不多讲了。 配置DNS地址进入万网-控制台-域名-具体域名管理-DNS修改修改DNS为DNSPod的免费DNS地址： f1g1ns1.dnspod.net f1g1ns2.dnspod.net 获取自己 github 的二级域名的 IP地址直接在终端输入以下命令(username换成自己的) ping username.github.io#例如：ping Vicxiaoyezi.github.io ``` ## 域名解析注册一个[DNSPod](https://www.dnspod.cn/)账号，登录之后把我们新注册的域名加进去，在域名解析界面添加3条记录 @ A 192.30.252.153@ A vic.kim.`如图所示。 设置CNAME在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。比如： 在github上面，打开username.github.io项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如： 到这里就绑定域名成功了。 最后晒上我的博客地址：vic.kim祝大家也早日拥有自己的博客~]]></content>
      <categories>
        <category>Hexo Next</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10分钟看懂Docker和K8S]]></title>
    <url>%2F2019%2F05%2F23%2F10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82Docker%E5%92%8CK8S%2F</url>
    <content type="text"><![CDATA[https://www.jianshu.com/p/f1f94c6968f5]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云储存选择做Hexo博客图床（腾讯云、七牛云、网易云）]]></title>
    <url>%2F2019%2F05%2F23%2F%E4%BA%91%E5%82%A8%E5%AD%98%E9%80%89%E6%8B%A9%E5%81%9AHexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%EF%BC%88%E8%85%BE%E8%AE%AF%E4%BA%91%E3%80%81%E4%B8%83%E7%89%9B%E4%BA%91%E3%80%81%E7%BD%91%E6%98%93%E4%BA%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言博客里需要添加很多图片作为内容的补充，但是把图片放在本地博客文件夹里，上传到网上后，加载这些图片就是一个很大的问题，他们会拖累网页加载的速度，所以建议把图片放图床里，通过外链来访问和加载这些图片。 云对象储存服务商国内免费的云对象储存的服务商(网易云、七牛云、腾讯云) 1.网易云官网：https://www.163yun.com/ 网易NOS（Netease Object Storage）网易对象存储为你提供基于互联网的数据存取服务，通过使用 NOS，你可以随时通过网络将你的文本、图片、音视频等各类文件存储到 NOS 系统中，并随时可以通过网络进行安全访问。 NOS 对象存储从三个维度进行计量收费：存储容量、流量、接口调用次数。存储容量0-50 GB是免费，下载流量在0-20 GB免费，每月前 10 万次 Put 请求免费，每月前 100 万次 Get 请求免费。 2.七牛云官网：https://www.qiniu.com/ 七牛云存储提供云存储、云处理、云加速分发一站式服务，注册成为标准用户后可获得10GB免费存储空间、每月10GB下载流量、每月10万次Put请求、每月100万次Get请求。 缺点：临时域名仅有三个月，三个月后没有自己的备案域名，所有图片均会失效 3.腾讯云官网：https://cloud.tencent.com/ 腾讯云对象存储服务COS，全称为Cloud Object Service，主要是为开发者提供安全、稳定、高效、实惠的对象存储服务，开发者可以将任意动态、静态生成的数据，存放到COS上，再通过HTTP的方式进行访问。 缺点：自2019年后新建用户可以领取一个6月有效期，50G的存储量。6月过后，按照存储量和流量收费。 在线图床选择https://sm.ms SM图床 https://tu.aixinxi.net/ 爱信息图床 https://imgchr.com/ 路过图床 总结云储存选择网易云，因为网易云对新用户的限制，免费的云储存有待选择 图床选择路过图床 目前还在用路过图床，缺点是图片链接不能看到任何图片名称等图片信息，不方便插入在博客里]]></content>
      <categories>
        <category>Hexo Next</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建立标签云及效果展示]]></title>
    <url>%2F2019%2F05%2F23%2FHexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E6%A0%87%E7%AD%BE%E4%BA%91%E5%8F%8A%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[hexo-tag-cloud插件介绍hexo-tag-cloud插件是作者写的一个Hexo博客的标签云插件，旨在直观的展示标签的种类，美观大方且非常优雅。 插件地址：插件的GitHub地址 插件说明：说明地址 标签云效果展示：我的博客主页插件作者提供的效果预览 安装插件进入到 hexo 的根目录，然后在 package.json 中添加依赖: &quot;hexo-tag-cloud&quot;: &quot;2.1.*&quot; 使用命令行进行安装npm install Git clone 下载使用命令行安装插件包的过程中可能会出现问题，安装失败，安装不完全。可以直接克隆插件到博客的插件文件夹blog/node_modules里。或者克隆到桌面，复制到博客的插件文件夹blog/node_modules里。 git clone https://github.com/MikeCoder/hexo-tag-cloud 配置插件插件的配置需要对应的环境，可以在主题文件夹里找一下，有没有对应的渲染文件，然后根据渲染文件的类型，选择对应的插件配置方法。 ##swig 用户 (Next主题为例)在主题文件夹找到文件 theme/next/layout/_macro/sidebar.swig, 然后添加如下代码： &#123;% if site.tags.length &gt; 1 %&#125;&lt;script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"&gt;&lt;/script&gt;&lt;div class="widget-wrap"&gt; &lt;h3 class="widget-title"&gt;Tag Cloud&lt;/h3&gt; &lt;div id="myCanvasContainer" class="widget tagcloud"&gt; &lt;canvas width="250" height="250" id="resCanvas" style="width=100%"&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 代码添加到后面即可，添加示意图如下: 对于ejs的用户 (默认主题landscape为例)在主题文件夹找到文件hexo/themes/landscape/layout/_widget/tagcloud.ejs,将这个文件修改如下： &lt;% if (site.tags.length) &#123; %&gt; &lt;script type="text/javascript" charset="utf-8" src="&lt;%- url_for('/js/tagcloud.js') %&gt;"&gt;&lt;/script&gt; &lt;script type="text/javascript" charset="utf-8" src="&lt;%- url_for('/js/tagcanvas.js') %&gt;"&gt;&lt;/script&gt; &lt;div class="widget-wrap"&gt; &lt;h3 class="widget-title"&gt;&lt;%= __('tagcloud') %&gt;&lt;/h3&gt; &lt;div id="myCanvasContainer" class="widget tagcloud"&gt; &lt;canvas width="250" height="250" id="resCanvas" style="width=100%"&gt; &lt;%- tagcloud() %&gt; &lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; 对于jade用户 (Apollo主题为例)找到 apollo/layout/archive.jade 文件，并且把 container 代码块修改为如下内容: block container include mixins/post .archive h2(class='archive-year')= 'Tag Cloud' script(type='text/javascript', charset='utf-8', src=url_for("/js/tagcloud.js")) script(type='text/javascript', charset='utf-8', src=url_for("/js/tagcanvas.js")) #myCanvasContainer.widget.tagcloud(align='center') canvas#resCanvas(width='500', height='500', style='width=100%') !=tagcloud() !=tagcloud() +postList() 主题配置在博客根目录，找到 _config.yml配置文件然后在最后添加如下的配置项，可以自定义标签云的字体和颜色，还有突出高亮: # hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica textColor: '#333' textHeight: 25 outlineColor: '#E2E1D1' maxSpeed: 0.1 效果预览本地预览hexo clean &amp;&amp; hexo g &amp;&amp; hexo s推荐使用 &amp;&amp; 作为组合命令的串联符号 构建hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 参考文章：Hexo Tag Cloud]]></content>
      <categories>
        <category>Hexo Next</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python+requests接口自动化测试]]></title>
    <url>%2F2019%2F05%2F23%2Fpython-requests%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[思路和框架正常的接口测试流程确定测试接口的工具 —&gt; 配置需要的接口参数 —&gt; 进行测试 —&gt; 检查测试结果（有的需要数据库辅助） —&gt; 生成测试报告（html报告）根据这样的过程来一步步搭建我们的框架。在这个过程中，我们需要做到业务和数据的分离，这样才能灵活，达到我们写框架的目的。接下来，我们来进行结构的划分。 common：存放一些共通的方法 result：执行过程中生成的文件夹，里面存放每次测试的结果 testCase：用于存放具体的测试case gitignore：Git忽略提交规则（不是必要） testFile：存放测试过程中用到的文件，包括上传的文件，测试用例以及数据库的sql语句 caselist：txt文件，配置每次执行的case名称 config：配置一些常量，例如数据库的相关信息，接口的相关信息等 readConfig： 用于读取config配置文件中的内容 runAll：用于执行case token.txt：本地换持有token config配置一些常量，例如数据库的相关信息，接口的相关信息等config.ini内容如下 [EMAIL]mail_host = smtp.qq.commail_user = xxx@qq.commail_pass = xxxmail_port = 465mail_replyto = xxx@ruguoapp.comsender = xxx@qq.comreceiver = xxx@qq.comsubject = "测试报告"content = "今天测试一下python是否可以发送邮件成功。"user = xxon_off = on[HTTP]scheme =httpsbase_url =xxxtimeout = 10.0[DATABASE]host = localhostusername = rootpassword = rootport = 3306database = test readConfig.py用来读取config配置文件中的内容，定义的方法，根据名称取对应的值内容如下 import osimport codecsimport configparserProDir = os.path.split(os.path.realpath(__file__))[0] # 该文件的绝对路径configPath = os.path.join(ProDir, "config.ini")class ReadConfig: def __init__(self): fd = open(configPath) data = fd.read() # remove BOM if data[:3] == codecs.BOM_UTF8: data = data[3:] file = codecs.open(configPath, "w") file.write(data) file.close() fd.close() self.cf = configparser.ConfigParser() self.cf.read(configPath) def get_email(self, name): value = self.cf.get("EMAIL", name) return value def get_http(self, name): value = self.cf.get("HTTP", name) return value def get_db(self, name): value = self.cf.get("DATABASE", name) return valueif __name__ == '__main__': # 测试一下，我们读取配置文件的方法是否可用 print('HTTP中的base_url值为：', ReadConfig().get_http('base_url')) common存放一些共通的方法conmmontest：操作本地caseconfigEmail：发送邮件configHttp：配置接口文件getHeades：获取请求头HTMLTestRunner：测试报告Token：tokenLog：输出的日志的所有操作，主要是对输出格式的规定，输出等级的定义以及其他一些输出的定义等等url：接口列表 Log对于这个log文件呢，我给它单独启用了一个线程，这样在整个运行过程中，我们在写log的时候也会比较方便，看名字大家也知道了，这里就是我们对输出的日志的所有操作了，主要是对输出格式的规定，输出等级的定义以及其他一些输出的定义等等。总之，你想对log做的任何事情，都可以放到这里来。 import osimport loggingimport threadinglocalReadConfig = readConfig.ReadConfig()class Log: logging.basicConfig() def __init__(self): global logPath, resultPath, path, logger_name path = readConfig.ProDir resultPath = os.path.join(path, "result") logger_name = 'logs' if not os.path.exists(resultPath): # 判断该文件是否存在 os.mkdir(resultPath) # 创建目录 logPath = os.path.join(resultPath, str(datetime.now().strftime("%Y%m%d%H%M%S"))) if not os.path.exists(logPath): os.mkdir(logPath) self.logger = logging.getLogger(logger_name) # 获得一个logger对象，默认是root self.logger.setLevel(logging.INFO) # 设定INFO级别，所有等级大于等于INFO的信息都会输出 # 定义handler handler = logging.FileHandler(os.path.join(logPath, "output.log")) # 向文件output.log输出日志信息 # 定义格式 formatter = logging.Formatter( '[%(asctime)s] &lt;%(levelname)s&gt; %(message)s') # 定义日志输出格式('%(asctime)s] %(levelname)s [%(funcName)s: %(filename)s, %(lineno)d] %(message)s') handler.setFormatter(formatter) # 选择一个格式 self.logger.addHandler(handler) # 增加指定的handler 现在，我们创建了上面的Log类，在init初始化方法中，我们进行了log的相关初始化操作。具体的操作内容，注释已经写得很清楚了，这样，log的基本格式已经定义完成了，至于其他的方法，就靠大家自己发挥了，毕竟每个人的需求也不同，我们就只写普遍的共用方法啦。接下来，就是把它放进一个线程内了，请看下面的代码： class MyLog: log = None mutex = threading.Lock() # 多线程 def __init__(self): pass @staticmethod def get_log(): if MyLog.log is None: MyLog.mutex.acquire() # 获取互斥锁后，进程只能在释放锁后下个进程才能进来 MyLog.log = Log() MyLog.mutex.release() # 互斥锁必须被释放掉 return MyLog.log configHttp.py配置接口文件，主要内容如下 import requestsimport readConfig as readConfigfrom common import getHeadersfrom common.Log import MyLog as LoglocalReadConfig = readConfig.ReadConfig()class ConfigHttp: def __init__(self): global scheme, host, timeout scheme = localReadConfig.get_http("scheme") host = localReadConfig.get_http("base_url") timeout = localReadConfig.get_http("timeout") self.log = Log.get_log() self.logger = self.log.get_logger() self.params = &#123;&#125; self.headers = None self.data = &#123;&#125; self.url = None self.files = None def set_url(self, url): self.url = scheme +'://'+host+url def set_headers(self): """ set headers """ self.headers = getHeaders.get_headers() def set_local_headers(self): """ set local headers """ self.headers = getHeaders.local_headers() def set_params(self, param): """ set params :param param: :return: """ self.params = param def set_data(self, data): """ set data :param data: :return: """ self.data = data def get(self): """ defined get method :return: """ try: response = requests.get(self.url, headers=self.headers, params=self.params, data=self.data) if response.status_code == 200: return response elif response.status_code == 401: getHeaders.refresh_tokens() response = requests.get(self.url, headers=self.headers, params=self.params, data=self.data) return response else: return response except TimeoutError: self.logger.error("Time out!") return None def post(self): """ defined post method :return: """ try: response = requests.post(self.url, headers=self.headers, params=self.params, data=self.data) if response.status_code == 200: return response elif response.status_code == 401: getHeaders.refresh_tokens() response = requests.post(self.url, headers=self.headers, params=self.params, data=self.data) return response else: return response except TimeoutError: self.logger.error("Time out!") return None def post_with_file(self): """ defined post method :return: """ try: response = requests.post(self.url, headers=self.headers, data=self.data, files=self.files, timeout=float(timeout)) return response except TimeoutError: self.logger.error("Time out!") return None def post_with_json(self): """ defined post method :return: """ try: response = requests.post(self.url, headers=self.headers, json=self.data, timeout=float(timeout)) return response except TimeoutError: self.logger.error("Time out!") return None 用python自带的requests来进行接口测试，，拿get和post两个方法来说吧。（平时用的最多的就是这两个方法了，其他方法，大家可以仿照着自行扩展） get方法接口测试中见到最多的就是get方法和post方法，其中，getget方法在传递参数后，url的格式是这样的：http://接口地址?key1=value1&amp;key2=value2， 对于requests提供的get方法，有几个常用的参数：url：显而易见，就是接口的地址url啦headers：定制请求头（headers），例如：content-type = application/x-www-form-urlencodedparams：用于传递测试接口所要用的参数，这里我们用python中的字典形式（key：value）进行参数的传递。timeout：设置接口连接的最大时间（超过该时间会抛出超时错误） 举个栗子：url=‘http://api.shein.com/v2/member/logout’header=&#123;‘content-type’： application/x-www-form-urlencoded&#125;param=&#123;‘user_id’： 123456,‘email’： 123456@163.com&#125;timeout=0.5requests.get（url, headers=header, params=param, timeout=timeout） post方法与get方法类似，只要设置好对应的参数，post方法中的参数，我们不在使用params进行传递，而是改用data进行传递了。 常用的返回值的操作。text：获取接口返回值的文本格式json()：获取接口返回值的json()格式status_code：返回状态码（成功为：200）headers：返回完整的请求头信息（headers[‘name’]：返回指定的headers内容）encoding：返回字符编码格式url：返回接口的完整url地址 举个栗子： url=‘http://api.shein.com/v2/member/login’header=&#123;‘content-type’： application/x-www-form-urlencoded&#125;data=&#123;‘email’： 123456@163.com,‘password’： 123456&#125;timeout=0.5requests.post（url, headers=header, data=data, timeout=timeout） 以上这些，就是常用的方法啦，大家可自行取之。 关于失败请求抛出异常，我们可以使用“raise_for_status()”来完成，那么，当我们的请求发生错误时，就会抛出异常。在这里提醒下各位朋友，如果你的接口，在地址不正确的时候，会有相应的错误提示（有时也需要进行测试），这时，千万不能使用这个方法来抛出错误，因为python自己在链接接口时就已经把错误抛出，那么，后面你将无法测试期望的内容。而且程序会直接在这里当掉，以错误来计。 common.py内容如下 import readConfigimport osfrom xlrd import open_workbookfrom common import configHttpfrom common.Log import MyLog as Logimport jsonlocalReadConfig = readConfig.ReadConfig()testFilePath = os.path.join(readConfig.ProDir,'testFile')localConfigHttp = configHttp.ConfigHttp()log = Log.get_log()logger = log.get_logger()caseNo = 0def get_value_from_return_json(response_json, name1, name2): """ get value by key :param response_json: :param name1: :param name2: :return: """ group = response_json[name1] value = group[name2] return valuedef get_value_dict_keys(dict): """ :param dict: :return: """ list = [i for i in dict] return listdef show_return_msg(response): """ show msg detail :param response: :return: """ url = response.url msg = response.text code=str(response.status_code) print("请求地址："+url) print("请求结果："+code) print("请求返回值："+'\n'+json.dumps(json.loads(msg), ensure_ascii=False, sort_keys=True, indent=4)) # print('Response HTTP Response Body:', json.dumps(self.response.json(), indent=2, sort_keys=True, ensure_ascii=False)) # indent: 缩进空格数，indent = 0输出为一行 # sort_keys = True: 将json结果的key按ascii码排序 # ensure_ascii = False: 不确保ascii码，如果返回格式为utf - 8包含中文，不转化为\u...# ****************************** read testCase excel ********************************# 从excel文件中读取测试用例def get_xls_case(xls_name, sheet_name): """ get interface data from xls file :return: """ cls = [] # 获取用例文件路径 xls_path = os.path.join(testFilePath, 'case', xls_name) # 打开用例Excel file = open_workbook(xls_path) # 获得打开Excel的sheet sheet = file.sheet_by_name(sheet_name) # 获取这个sheet内容行数 rows = sheet.nrows for i in range(rows):#根据行数做循环 if sheet.row_values(i)[0] != u'case_name':#如果这个Excel的这个sheet的第i行的第一列不等于case_name那么我们把这行的数据添加到cls[] cls.append(sheet.row_values(i)) return cls 上面就是common主要内容。主要利用xlrd来操作excel文件，注意啦，我们是用excel文件来管理测试用例的。 configEmail.py发送邮件 # coding:utf-8import osimport smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom email.mime.application import MIMEApplication #主要类型的MIME消息对象应用from email.mime.multipart import MIMEMultipartfrom email.mime.image import MIMEImagefrom datetime import datetimeimport threadingimport readConfig as readConfigfrom common.Log import MyLoglocalReadConfig = readConfig.ReadConfig()class Email: def __init__(self): global host, user, password, port, sender, title,receivers sender = localReadConfig.get_email("sender") # 发件人 receivers = ['8463299@qq.com'] # 收件人 # receivers = ['test@163.com','test@vip.qq.com'] # 接收多个邮件，可设置为你的QQ邮箱或者其他邮箱 host = localReadConfig.get_email("mail_host")# 设置服务器 port = localReadConfig.get_email("mail_port") # 设置服务器 user = localReadConfig.get_email("mail_user")# QQ邮件登录名称 password = localReadConfig.get_email("mail_pass")# QQ邮箱的授权码 title = localReadConfig.get_email("subject")#邮件主题 # 定义邮件主题 date = datetime.now().strftime("%Y-%m-%d %H:%M:%S") self.subject = "接口测试报告" + " " + date self.log = MyLog.get_log() self.logger = self.log.get_logger() self.msg = MIMEMultipart('related') def config_header(self): """ defined email header include subject, sender and receiver :return: """ self.msg['Subject'] = Header(self.subject) # 邮件主题 self.msg['From'] = Header(sender) # 发件人 self.msg['To'] = Header(str(";".join(receivers))) # 收件人 def config_content(self): """ write the content of email :return: """ self.config_file_html_img() self.config_file() def config_file_html_img(self): file_path = os.path.join(readConfig.ProDir, 'testFile', 'emailStyle.html') # 文件路径 with open(file_path, 'rb') as fp: # 读取文件内容 msg_text = MIMEText(fp.read(), 'html', 'utf-8') # 创建Text对象，包括文本内容 self.msg.attach(msg_text) # 构建HTML格式的邮件内容 image2_path = os.path.join(readConfig.ProDir, 'testFile', 'img', 'smile.jpg') # 图片路径 self.msg.attach(self.add_image(image2_path, '&lt;image2&gt;')) # 构建HTML格式的邮件内容 def config_file_html(self): report_file_path = self.log.get_report_file_path() with open(report_file_path, encoding='utf-8') as f: # 打开html报告 email_body = f.read() # 读取报告内容 self.msg = MIMEMultipart() # 混合MIME格式 self.msg.attach(MIMEText(email_body, 'html', 'utf-8')) def config_file(self): if self.check_file(): report_folder_path = self.log.get_result_folder_path() filename = [os.path.join(report_folder_path, 'output.log'), os.path.join(report_folder_path, 'report.html')] for tmp in filename: with open(tmp, 'rb') as f: attach_files = MIMEApplication(f.read()) attach_files.add_header('Content-Disposition', 'attachment', filename=tmp) self.msg.attach(attach_files) def add_image(self,src, img_id): # xml中添加图片 with open(src, 'rb') as f: msg_image = MIMEImage(f.read()) # 读取图片内容 msg_image.add_header('Content-ID', img_id) # 指定文件的Content-ID,&lt;img&gt;,在HTML中图片src将用到 return msg_image def check_file(self): """ check test report :return: """ report_path = self.log.get_report_file_path() if os.path.isfile(report_path) and not os.stat(report_path) == 0: return True else: return False def send_email(self): """ send email :return: """ global smtp self.config_content() self.config_header() try: smtp = smtplib.SMTP_SSL(host,port) smtp.login(user, password) smtp.sendmail(sender, receivers, self.msg.as_string()) self.logger.info("测试报告已通过电子邮件发送给开发人员") except Exception as ex: self.logger.error(str(ex)) return "邮件发送失败" finally: smtp.quit()class MyEmail: email = None mutex = threading.Lock() def __init__(self): pass @staticmethod def get_email(): if MyEmail.email is None: MyEmail.mutex.acquire() MyEmail.email = Email() MyEmail.mutex.release() return MyEmail.emailif __name__ == "__main__": email = MyEmail.get_email() HTMLTestRunner.pyHTMLTestRunner.py这个文件从网上下载的，大神写好的，用于生成html格式的测试报告生成报告如下 runAll.py这是整个框架运行的入口 import osimport unittestfrom common.Log import MyLog as Logimport readConfig as readConfigfrom common import HTMLTestRunnerfrom common.configEmail import MyEmaillocalReadConfig = readConfig.ReadConfig()class AllTest: def __init__(self): global log, logger, resultPath, on_off log = Log.get_log() logger = log.get_logger() resultPath = log.get_report_file_path() on_off = localReadConfig.get_email("on_off") self.caseListFile = os.path.join(readConfig.ProDir, "caseList.txt") self.caseFile = os.path.join(readConfig.ProDir, "testCase") self.caseList = [] self.email = MyEmail.get_email() def set_case_list(self): """ set case list :return: """ fb = open(self.caseListFile) for value in fb.readlines(): data = str(value) if data != '' and not data.startswith("#"): self.caseList.append(data.replace("\n", "")) fb.close() def set_case_suite(self): """ set case suite :return: """ self.set_case_list() test_suite = unittest.TestSuite() suite_module = [] for case in self.caseList: case_name = case.split("/")[-1] print(case_name + ".py") discover = unittest.defaultTestLoader.discover(self.caseFile, pattern=case_name + '.py', top_level_dir=None) suite_module.append(discover) if len(suite_module) &gt; 0: for suite in suite_module: for test_name in suite: test_suite.addTest(test_name) else: return None return test_suite def run(self): """ run test :return: """ try: suit = self.set_case_suite() if suit is not None: logger.info("================================== 测试开始 ==================================") fp = open(resultPath, 'wb') runner = HTMLTestRunner.HTMLTestRunner(stream=fp, title='即刻接口测试报告', description='用例执行情况') runner.run(suit) fp.close() else: logger.info("没有需要测试的案例") except Exception as ex: logger.error(str(ex)) finally: # 通过电子邮件发送测试报告 if on_off == 'on': self.email.send_email() elif on_off == 'off': logger.info("不向开发人员发送报告电子邮件") else: logger.info("未知状态") logger.info("================================== 测试结束 ==================================")if __name__ == '__main__': obj = AllTest() obj.run() 上面贴出了runAll里面的主要部分，首先我们要从caselist.txt文件中读取需要执行的case名称，然后将他们添加到python自带的unittest测试集中，最后执行run()函数，执行测试集。 resultresult文件夹会在首次执行case时生成，并且以后的测试结果都会被保存在该文件夹下，同时每次测试的文件夹都是用系统时间命名，里面包含了两个文件，log文件和测试报告 testCasetestCase文件夹下，存放我们写的具体的测试case。注意，所有的case名称都要以test开头来命名，因为unittest在进行测试时会自动匹配testCase文件夹下面所有test开头的.py文件 testFiletestFile文件夹下，放置我们测试时用来管理测试用例的excel文件和用于数据库查询的sql语句的xml文件。 caselist.txt凡是没有被注释掉的，都是要被执行的case名称啦。在这里写上你要执行的case名称就可以啦。 参考https://my.oschina.net/u/3041656/blog/820023?p=7参考源码https://gitee.com/null_534_6629/interfacetest/tree/master]]></content>
      <categories>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>接口测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 主题中添加本地搜索功能]]></title>
    <url>%2F2019%2F05%2F22%2FHexo%20Next%20%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[关于随着时间的推移，个人站点的博客文章会越来越多，那怎么样才能快速找到你印象中的文章呢？增加一个站点内的搜索功能是非常有必要和方便的。 安装本地搜索插件 hexo-generator-search在博客根目录下执行下列命令 npm install hexo-generator-search --save 安装之后，会在站点目录的 public 文件夹下创建一个 search.xml 文件。 修改全局配置文件_config.yml（博客根目录）在站点配置文件 _config.yml 中添加如下内容： # Search search: path: ./public/search.xml field: post format: html limit: 10000 path：索引文件的路径，相对于站点根目录field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面limit：限制搜索的条目数 hexo主题配置文件（/themes/next/_config.yml）在主题配置文件 _config.yml 中找到如下内容： local_search: enable: true trigger: auto top_n_per_article: 1 修改local_search的enable为true top_n_per_article字段表示在每篇文章中显示的搜索结果数量，设成 -1 会显示每篇文章的所有搜索结果数量。 重新部署然后执行以下命令，重新部署网站即可愉快的使用本地搜索功能了 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d]]></content>
      <categories>
        <category>Hexo Next</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles的使用]]></title>
    <url>%2F2019%2F05%2F22%2FCharles%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Charles 简介Charles 是一个支持多平台的 HTTP 代理器、HTTP 监控、反向代理器。它能够让开发者查看本地机器与互联网之间的所有 HTTP 以及 SSL/HTTPS 传输数据。包括请求数据、响应数据 以及 HTTP 头部信息（包括 Cookie 和缓存信息）。 Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响. Charles 主要的功能包括： 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络。 支持SSL代理。可以截取分析SSL的请求。 支持端口映射。 支持反向代理。 支持SOCKS 下载安装 Charles 打开浏览器访问 Charles 官网 ，下载相应系统的 Charles 安装包，然后安装即可 Mac版Charles 4.2.7破解版，百度网盘地址，安装密码：www.ifunmac.com 安装Charles 打开 Charles for Mac 4.2.7.dmg 包，后将 Charles 拖到 Application 目录下即完成安装。 安装完毕后，进行破解，方法很简单: Mac 将 charles.jar 覆盖到 安装包Contents/Java 下； Charles 主界面介绍Charles 的主界面视图如下图所示： 工具导航栏Charles 顶部为菜单导航栏，菜单导航栏下面为工具导航栏。视图如下图所示：工具导航栏中提供了几种常用工具，依次为： 清除捕获到的所有请求 红点状态说明正在捕获请求，灰色状态说明目前没有捕获请求。 灰色状态说明是没有开启网速节流，绿色状态说明开启了网速节流。 灰色状态说明是没有开启断点，绿色状态说明开启了断点。 编辑修改请求，点击之后可以修改请求的内容。 重复发送请求，点击之后选中的请求会被再次发送。 验证选中的请求的响应。 常用功能，包含了 Tools 菜单中的常用功能。 常用设置，包含了 Proxy 菜单中的常用设置。 主界面视图Charles 主要提供两种查看封包的视图，分别名为 Structure 和 Sequence。 Structure： 此视图将网络请求按访问的域名分类。 Sequence： 此视图将网络请求按访问的时间排序。 使用时可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 Filter 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。 对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。 Charles 菜单介绍Charles 的主菜单包括：File、Edit、View、Proxy、Tools、Window、Help。用的最多的主菜单分别是 Proxy 和 Tools。 Proxy 菜单Charles 是一个 HTTP 和 SOCKS 代理服务器。代理请求和响应使 Charles 能够在请求从客户端传递到服务器时检查和更改请求，以及从服务器传递到客户端时的响应。下面主要介绍 Charles 提供的一些代理功能。Proxy 菜单的视图如下图所示： Proxy 菜单包含以下功能： Start/Stop Recording：开始/停止记录会话。 Start/Stop Throttling：开始/停止节流。 Enable/Disable Breakpoints：开启/关闭断点模式。 Recording Settings：记录会话设置。 Throttle Settings：节流设置。 Breakpoint Settings：断点设置。 Reverse Proxies Settings：反向代理设置。 Port Forwarding Settings：端口转发。 Windows Proxy：记录计算机上的所有请求。 Proxy Settings：代理设置。 SSL Proxying Settings：SSL 代理设置。 Access Control Settings：访问控制设置。 External Proxy Settings：外部代理设置。 Web Interface Settings：Web 界面设置。 Recording Settings(记录会话设置)Recording Settings 和 Start/Stop Recording 配合使用，在 Start Recording 的状态下，可以通过 Recording Settings 配置 Charles 的会话记录行为。Recording Settings 的视图如下图所示：Recording Settings 有 Options、Include、Exclude 三个选项卡： Options：通过 Recording Size Limits 限制记录数据的大小。当 Charles 记录时，请求、响应头和响应体存储在内存中，或写入磁盘上的临时文件。有时，内存中的数据量可能会变得太多，Charles 会通知您并停止录制。在这种情况下，您应该清除 Charles 会话以释放内存，然后再次开始录制。在录制设置中，您可以限制 Charles 将记录的最大大小; 这根本不会影响你的浏览，Charles 仅会停止录制。 Include：只有与配置的地址匹配的请求才会被录制。 Exclude：只有与配置的地址匹配的请求将不会被录制。Include 和 Exclude 选项卡的操作相同，选择 Add，然后填入需要监控的Procotol、Host 和 Port等信息，这样就达到了过滤的目的。如下图所示： Throttle Settings(节流设置)Throttle Settings 和 Start/Stop Throttling 配合使用，在 Start Throttling 的状态下，可以通过 Throttle Settings 配置 Charles 的网速模拟配置。Throttle Settings 的视图如下图所示： 勾选 Enable Throttling 启用网速模拟配置，在 Throttle Preset 下选择网络类型即可，具体设置可以根据实际情况自行设置。如果只想模拟指定网站的慢速网络，可以再勾选上图中的 Only for selected hosts 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 Throttle Settings 视图中的选项含义如下： Bandwidth：带宽 Utilistation：利用百分比 Round-trip：往返延迟 MTU：字节 Breakpoint Settings(断点设置)Breakpoint Settings 和 Enable/Disable Breakpoints 配合使用，在 Enable Breakpoints 的状态下，可以通过 Breakpoint Settings 配置 Charles 的断点模式。Breakpoint Settings 的视图如下图所示：勾选 Enable Breakpoints 启用断点模式，选择 Add，然后填入需要监控的Scheme、Procotol、Host 和 Port 等信息，这样就达到了设置断点的目的。然后可以来观察或者修改请求或者返回的内容，但是在这过程中需要注意请求的超时时间问题。或者可以在某个想要设置断点的请求网址上右击选择 Breakpoints 来设置断点。 Reverse Proxies Settings(反向代理设置)反向代理在本地端口上创建 Web 服务器，该端口透明地将请求代理给远程 Web 服务器。反向代理上的所有请求和响应都可以记录在 Charles 中。如果您的客户端应用程序不支持使用 HTTP 代理，或者您希望避免将其配置为使用代理，那么反向代理很有用。创建原始目标 Web 服务器的反向代理，然后将客户端应用程序连接到本地端口； 反向代理对客户端应用程序是透明的，使您可以查看 Charles 以前可能无法访问的流量。有关反向代理的更多信息，请访问 Reverse proxy Port Forwarding Settings(端口转发)可以将任何 TCP/IP 或 UDP 端口配置为使用 Port Forwarding 工具从 Charles 转发到远程主机。这样可以调试 Charles 中的任何协议。在 Macromedia Flash 中调试 XMLSocket 连接时，这尤其有用。还可以使用 Charles 作为 SOCKS 代理，因此无需设置端口转发。 macOS Proxy(记录计算机上的所有请求)如果想要抓取电脑端的请求，勾选 Windows Proxy 选项即可；如果只需要抓取手机请求，则取消勾选这个选项。 Proxy Settings(代理设置)Proxy Settings 的视图如下图所示：代理端口默认为 8888(可以修改)，并且勾上 Enable transparent HTTP proxying 就完成了在 Charles 上的代理设置。 SSL Proxy Settings(SSL 代理设置)SSL Proxy Settings 的视图如下图所示：勾上 Enable SSL proxying 就完成了在 Charles 上的 SSL 代理设置。之后也可以选择 Add，然后填入需要监控的 Host 和 Port 信息，这样就达到了针对某个域名启用 SSL 代理的目的。 Access Control Settings(访问控制设置)Access Control Settings 表示访问控制设置。访问控制列表确定谁可以使用此 Charles 实例。通常，您在自己的计算机上运行 Charles，并且您只打算自己使用它，因此 localhost 始终包含在访问控制列表中。也可以选择 Add，然后填入允许访问的 IP，这样就达到了允许某个 IP 访问 Charles 的目的。 External Proxy Settings(外部代理设置)External Proxy Settings 表示外部代理设置。可能在网络上有一个代理服务器，必须使用该代理服务器才能访问 Internet。在这种情况下，需要将 Charles 配置为在尝试访问 Internet 时使用现有代理。 可以配置单独的代理地址和端口： HTTP HTTPS SOCKS Web Interface Settings(Web 界面设置)Web Interface Settings 表示 Web 界面设置。Charles 有一个 Web 界面，可以让您从浏览器控制 Charles，或使用 Web 界面作为 Web 服务使用外部程序。 在 External Proxy Settings 视图中勾选 Enable the web interface 选项启用 Web 界面。可以允许匿名访问，也可以配置用户名和密码。还可以通过在配置使用 Charles 作为其代理的 Web 浏览器中访问 http://control.charles/ 来访问 Web 界面。Web界面提供对以下功能的访问： 节流控制 激活或停用任何已配置的限制预设 录音控制 开始和停止会话录制 工具 激活和停用工具 会话控制 清除当前会话 以任何支持的格式导出当前会话 以 Charles 的本机会话格式下载当前会话退出Charles 通过检查 Web 界面 HTML ，您可以推导出如何将其用作 Web 服务来自动化 Charles。 Tools 菜单Charles 是一个 HTTP 和 SOCKS 代理服务器，所有的请求都会经过 Charles。下面主要介绍 Charles 提供的一些实用工具。Tools 菜单的视图如下图所示：Tools 菜单包含以下功能： No Caching Settings：禁用缓存设置。 Block Cookies Settings：禁用 Cookie设置。 Map Remote Settings：远程映射设置。 Map Local Settings：本地映射设置。 Rewrite Settings：重写设置。 Black List Settings：黑名单设置。 White List Settings：白名单设置。 DNS Spoofing Settings：DNS 欺骗设置。 Mirror Settings：镜像设置。 Auto Save Settings：自动保存设置。 Client Process Settings：客户端进程设置。 Compose：编辑修改。 Repeat：重复发包。 Repeat Advanced：高级重复发包。 Validate：验证。 Publish Gist：发布要点。 Import/Export Settings：导入/导出设置。 Profiles：配置文件。 Publish Gist Settings：发布要点设置。 No Caching Settings(禁用缓存)No Caching 工具可防止客户端应用程序（如 Web 浏览器）缓存任何资源。因此，始终向远程网站发出请求，您始终可以看到最新版本。 适用范围该工具可以作用于每个请求(选中 Enable No Caching 即可)，也可以仅对你配置的请求启用(启用 No Caching 的同时，请选中 Only for selected locations)。当用于选定的请求时，可以使用简单但功能强大的模式匹配将工具的效果限制为指定的主机和路径。 工作原理No Caching 工具通过操纵控制响应缓存的 HTTP 请求头来防止缓存。从请求中删除 If-Modified-Since 和 If-None-Match 请求头，添加 Pragma：no-cache 和 Cache-control：no-cache。从响应中删除 Expires，Last-Modified 和ETag 请求头，添加 Expires：0 和 Cache-Control：no-cache。 Block Cookies Settings(禁用 Cookie)Block Cookies 工具阻止了 Cookie 的发送和接收。它可用于测试网站，就像在浏览器中禁用了 Cookie 一样。 请注意，网络爬虫（例如 Google）通常不支持 Cookie，因此该工具还可用于模拟网络爬虫网站的视图。 适用范围该工具可以作用于每个请求(选中 Enable Block Cookies 即可)，也可以仅对你配置的请求启用(启用 Block Cookies 的同时，请选中 Only for selected locations)。当用于选定的请求时，可以使用简单但功能强大的模式匹配将工具的效果限制为指定的主机和路径。 工作原理Block Cookies 工具通过操纵控制响应 Cookies 的 HTTP 请求头来禁用 Cookies。从请求中移除 Cookie 请求头，防止 Cookie 值从客户端应用程序（例如 Web 浏览器）发送到远程服务器。从响应中删除 Set-Cookie 请求头，防止请求设置客户端应用程序从远程服务器接收的 Cookie。 Map Remote Settings(远程映射)Map Remote 工具根据配置的映射更改请求站点，以便从新站点透明地提供响应，就好像这是原始请求一样。 通过此映射，您可以从另一个站点提供全部或部分站点。例如： 可以把 xk72.com/charles/ 映射到 localhost/charlesdev/ 来为 xk72.com 提供一个子目录； 可以把 xk72.com/*.php 这种指定后缀的所有文件映射到 localhost/charlesdev/。 使用建议如果您拥有站点的开发版本并且希望能够通过开发提供的某些请求浏览实时站点，则 Map Remote 非常有用。例如，您可能希望从开发服务器提供 css 和 images 目录。使用 live.com/css/ 等映射到 dev.com/css/ 或 live.com/*.css 到 dev.com 。 映射类型 可以将目录映射到目录，如 xk72.com/charles/ 映射到 localhost/charlesdev/； 可以将文件映射到文件，如 xk72.com/charles/dow… 映射到 abc.com/testing/tes… 可以将带有文件模式的目录映射到目录，如 xk72.com/charles/*.p… 到 localhost/charlesdev/； 如果在目标映射中未指定路径，则 URL 的路径部分将不会更改。如果要映射到根目录，请在目标路径字段中已 / 结尾。 HTTPSMap Remote 工具可以将 HTTP 请求映射到 HTTPS 目标，反之亦然，因此您可以将 HTTP 或 HTTPS 站点映射到其对立面。 站点匹配每个站点匹配可能包含协议、主机、端口和路径模式，以匹配特定的 URL。站点可能包括通配符。当您向此工具添加新站点时，可能会找到有关创建站点匹配的更多帮助。 Map Local Settings(本地映射)Map Local 工具使您可以使用本地文件，就像它们是远程网站的一部分一样。您可以在本地开发文件，并像在线上一样测试它们。本地文件的内容将返回给客户端，就像它是正常的远程响应一样。Map Local 可以大大加快开发和测试速度，否则您必须将文件上传到网站以测试结果。使用 Map Local，您可以在开发环境中安全地进行测试。 动态文件动态文件（例如包含服务器端脚本的文件）不会由 Map Local 执行，因此如果文件中有任何脚本，脚本将按原样返回到浏览器，这可能不是预期的结果。如果您想使用动态文件，就好像它们是远程网站的一部分一样，请参阅 Map Remote 工具。 工作原理当请求与 Map Local 映射匹配时，它会检查与路径匹配的本地文件。它不包括查询字符串（如果有）。如果在本地找到所请求的文件，则将其作为响应返回，就好像它是从远程站点加载的一样，因此它对客户端是透明的。如果在本地找不到所请求的文件，那么该请求会像平常一样由网站提供，返回由真正的服务器提供的数据。 站点匹配每个站点匹配可能包含协议、主机、端口和路径模式，以匹配特定的 URL。站点可能包括通配符。当您向此工具添加新站点时，可能会找到有关创建站点匹配的更多帮助。 Rewrite Settings(重写)Rewrite 工具允许创建请求和响应在通过 Charles 时修改他们的规则。如：添加或更改头信息、搜索和替换响应内容中的某些文本等。 重写集重写集可以单独激活和停用。每个集合包含站点和规则的列表。这些站点选择规则将要运行的请求和响应。 重写规则每个规则都描述了一次重写操作。规则可能会影响请求URL的 Header，正文或部分内容；它可以根据请求或响应来操作；它可以定义搜索、替换或者仅替换样式重写。 站点匹配每个站点匹配可能包含协议、主机、端口和路径模式，以匹配特定的 URL。站点可能包括通配符。当您向此工具添加新站点时，可能会找到有关创建站点匹配的更多帮助。 调试当重写操作未按预期工作时，重写工具可能难以调试。如果您遇到问题，请尝试添加一个非常基本的规则，例如添加明显头信息的规则，以便您可以查看规则是否与请求完全匹配。同时打开错误日志中的调试，以获取从 Charles 中的 Window 菜单访问的错误日志中打印的一些调试信息。 Black List Settings(黑名单)Black List 工具允许输入应该被阻止的域名。当 Web 浏览器尝试从被列入黑名单的域名请求任何页面时，该请求将被 Charles 阻止。您还可以输入通配符来阻止其子域名。 White List Settings(白名单)Black List 工具允许输入仅仅被允许的域名。Black List 工具将阻止除被列入白名单的域名之外的所有请求。 白名单工具用于仅允许指定的域名；黑名单工具，用于仅屏蔽指定的域名。如果一个请求与“黑名单”和“白名单”都匹配，则该请求会被阻止。 DNS Spoofing Settings(DNS 欺骗)DNS Spoofing 工具允许通过将自己的主机名指定给远程地址映射来欺骗 DNS 查找。 当请求通过 Charles 时，您的 DNS 映射将优先。Charles 包含配置的域名到 IP 地址映射的列表。当针对列出的域名发出请求时，Spoof DNS 插件会发现欺骗 IP 将请求重定向到该地址。主机HTTP标头保持不变，因此就像您的 DNS 服务器返回欺骗性 IP一样。 虚拟主机虚拟主机是指单个IP地址上有多个站点，Web 服务器根据浏览器中键入的名称确定要请求的站点。更准确地说，它查看请求中发送的主机头。如果没有为您的站点设置 DNS，那么您通常无法测试它，因为您不能只输入 IP 地址，因为服务器无法获取名称，因此无法将请求与网站。使用 DNS 欺骗工具来克服此问题。 Mirror Settings(镜像)Mirror 工具会在浏览指定站点时，把接收到的响应内容克隆一份，并保存在磁盘上指定的路径下。保存文件的路径会与浏览站点的目录结构相同，并且 Charles 会为主机名创建一个根目录。文件名从 URL 导出并转换为适合的数据进行保存。查询字符串包含在文件名中。如果收到相同 URL 的两个响应，则后面一个文件会覆盖前面的同名文件，因此保存在镜像中在的响应内容将始终为最新的。 选定站点可以为每个请求启用该工具，也可以仅为指定站点启用该工具。当用于选定的站点时，可以使用简单但功能强大的模式匹配将工具的效果限制为指定的主机和/或路径。 副作用如果为请求启用镜像工具，它将导致任何压缩或编码的响应被解码。因此，如果服务器提供了压缩响应，Charles 将在传递给客户端之前对其进行解压缩，这通常不会产生任何影响。但是如果您已经构建了自己的客户端，或者客户端希望得到压缩响应，此时将会产生影响。使用 web 浏览器则没有任何影响。 Auto Save Settings(自动保存)Auto Save 工具会按设定的时间间隔自动保存和清除记录会话。 如果您让 Charles 长时间监控网络活动，并希望将记录分解为可管理的单元，或者避免因数据量过大而可能出现的内存不足情况，这将非常有用。 输入以分钟为单位的保存间隔以及保存会话文件的目录。您可以选择是否在每次运行 Charles 时启动 Auto Save 工具，否则在 Charles 启动时将始终禁用 Auto Save 工具。 会话文件的名称中保存时间戳，格式为 yyyyMMddHHmm，即年月日时分，以便按字母顺序排序时，它们以正确的顺序显示。 Client Process Settings(客户端进程)Client Process 工具显示负责发出每个请求的本地客户端进程的名称。客户端进程通常是您的 Web 浏览器(例如 firefox.exe)，但客户端进程工具可以帮助您发现许多可能未知的 HTTP 客户端。客户端进程名称显示在每个请求的 Notes 区域中。如果您可以在 Charles 中看到不确定原始进程的请求，则客户端进程工具很有用。 它仅适用于在运行 Charles 的计算机上发出的请求。在 Charles 接受每个连接之前，该工具将引入一个短暂的延迟。 延迟通常不明显或不显著。 选定站点可以为每个请求启用该工具，也可以仅为指定站点启用该工具。当用于选定的站点时，可以使用简单但功能强大的模式匹配将工具的效果限制为指定的主机和/或路径。 Compose(编辑修改)Compose 工具允许在原有的请求基础上修改。 Repeat(重复)Repeat 工具允许选择一个请求并重复它。Charles 将请求重新发送到服务器，并将响应显示为新请求。如果您正在进行后端更改并希望在浏览器(或其他客户机)中重复请求的情况下测试这些更改，那么这将非常有用。特别是如果重新创建请求需要花费一些精力，例如在游戏中获得分数，这将节省大量精力。重复请求是在 Charles 内部完成的，因此无法在浏览器或其他客户端中查看响应，响应只能在 Charles 中查看。 Repeat Advanced(高级重复)Repeat Advanced 工具扩展了 Repeat 工具，提供了迭代次数和并发数的选项。这对于负载测试非常有用。 Validate(验证)Validate 工具允许 Charles 通过将它们发送到 W3C HTML 验证器、W3C CSS 验证器和 W3C Feed 验证器来验证记录的响应。验证报告在 Charles 中显示，其中包含与响应源中相应行相关联的任何警告或错误（双击错误消息中的行号可以切换到源视图）。因为 Charles 测试它记录的响应，所以它可以测试不易测试的场景，例如在提交表单后呈现错误消息。 重新验证验证后，可以从验证结果中选择响应并 Repeat，重复原始请求，然后重新验证结果。 Publish Gist(发布要点)Publish Gist 工具可以将将所选请求和响应作为要点发布。默认情况下，这个要点将匿名发布，这意味着你将无法做到删除它。可以在 Tools 菜单的 Publish Gist Settings 中授权 Charles 使用您的 GitHub 帐户进行发布。 Import/Export Settings(导入/导出)Import/Export 工具允许导入/导出 Charles 的 Proxy、Tools、Preferences 等设置。 Profiles(配置)Profiles 包含所有配置设置的完整副本。每次更改当前设置时，系统都会更新当前活动的配置文件，当您更改活动配置文件时，所有设置都将恢复为上次使用该配置文件时的状态。请注意，如果导入已保存的配置，则会覆盖当前配置文件的设置。建议使用导入/导出来备份或创建当前配置和配置文件的快照，以维护多个并行工作区。 Charles 使用教程通过 Charles 进行 PC 端抓包Charles 会自动配置浏览器和工具的代理设置，所以说打开工具直接就已经是抓包状态了。只需要保证一下几点即可： 确保 Charles 处于 Start Recording 状态。勾选 Proxy | macOS Proxy。 通过 Charles 进行移动端抓包 电脑端配置： 打开 Charles 的代理功能： 通过主菜单打开 Proxy | Proxy Settings 弹窗，查看代理端口(端口默认为 8888，不用修改) 手机端配置： 打开 iPhone 设置 - 无线局域网，将手机网络连接到与电脑相同WiFi 点击WiFi详情按钮设置HTTP代理，将其改为手动，然后填写Charles所在电脑的代理IP地址，端口号默认为8888。 设置好之后，我们打开手机上的任意需要网络请求的程序，就可以看到 Charles 弹出手机请求连接的确认菜单（只有首次弹出），点击 Allow 即可完成设置。 完成以上步骤，就可以进行抓包了。 通过 Charles 进行 HTTPS 抓包HTTPS 的抓包需要在 HTTP 抓包基础上再进行设置。需要完成步骤： 电脑端安装 Charles 证书：通过 Charles 菜单栏找到 Help - SSL Proxying - Install Charles Root Certificate 安装证书，然后给电脑安装证书，信任证书 设置 SSL 代理：通过主菜单打开 Proxy - SSL Proxy Settings 弹窗，勾选 Enable SSL proxying。并添加域名端口，匹配想要监听的域名端口，这里可以添加:443或:*匹配全部： 移动端安装 Charles 证书：通过 Charles 的主菜单Help - SSL Proxying - Install Charles Root Certificate on a Mobile Device or Remote Browser.. ，按照弹出的提示会让你将手机切换为手动代理到电脑的Charles，然后用浏览器打开提示上面的地址下载安装证书 iPhone需要信任证书。设置 - 通用 - 描述文件与设备管理 - 点击证书信任 设置好之后，我们打开手机上的任意需要网络请求的程序，就可以进行 HTTPS 抓包了。 Focus 功能使用 Focus 功能指定想要查看的域名，可以避免这个域名相关的请求淹没在茫茫请求当中。当然使用“Structure”视图也可以避免这个问题。对想要Focus的域名，选中抓取的接口-右键菜单-选择Focus，这个域名就会添加到Focused列表，可以在这里找到： 重复请求功能Repeat使用Repeat Advanced 还可以指定请求次数 查找功能选中抓取的接口-右键菜单-选择Find In 即可打开查找面板 双击查找结果会跳到想要的结果 设置断点拦截请求响应首先开启断点功能，然后再到想要设置断点的请求上，右键设置一个断点，如图所示：查看是否加入断点设置面板默认拦截请求和响应，如果只需要两者之一，可以选择设置再次发起请求，就会看到拦截了请求和响应]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman的使用]]></title>
    <url>%2F2019%2F05%2F22%2FPostman%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[常见接口测试工具 Postman: 简单方便的接口调试工具，便于分享和协作。具有接口调试，接口集管理，环境配置，参数化，断言，批量执行，录制接口，Mock Server, 接口文档，接口监控等功能 JMeter: 开源接口测试及压测工具，支持Linux及无界面运行 LR: 商业版接口性能测试工具，简单易用，功能强大 SoupUI: 开源，WebService接口常用测试工具，也可以测试Rest接口及接口安全 新版Postman使用简介Postman 官网地址：https://www.getpostman.com/pricing 工具栏 New: 新建，可以新建Request请求，Collection请求集，环境等等 Import: 导入，可以导入别人导出的请求集 Runner: 运行一个请求集（批量执行） Invite: 邀请（需要注册，邀请进行协作） 同步图标： （需要注册，同步你的项目到云端） 抓包图标： 抓包/捕获请求，用于开启Postman代理， 手动设置代理（或手机代理）后可抓包/录制请求 设置图标： Postman设置 消息图标： 官方及协助消息 收藏图标： 我的收藏（需要注册） 云端图标： 用户云端数据（需要注册） 接口管理区 History: 请求历史记录，可以查询到之前的请求记录 Collections: 接口集，相当于一个接口项目或测试计划，接口集中可以建立无限极子文件夹，用于对接口进行分组管理 环境管理区 环境切换：用于切换环境 环境预览：用于快速预览环境中的所有变量 环境管理：用于添加修改环境及环境变量，以及全局变量 什么是环境接口完整地址 = 服务地址 + 接口地址， 如https://app.jike.ruguoapp.com + /1.0/users/login环境是一套配置，包含许多环境变量。在接口测试中，根据部署在不同的服务器上，服务器地址有可能不同，而同一个接口，接口地址是不变的。为了测试部署在不同服务器上的同一套接口，我们可以建立不同的环境，不同环境中host变量使用不同的地址 接口设计区可以通过上方tab边上的+号，新建多个请求。接口设计区从上到下分为请求区和响应区 请求区 请求地址行：可以选择请求方法（GET/POST/…），填写请求地址，发送请求和保存请求到测试集 请求数据区：分为授权，请求头，请求数据，请求发送前执行的脚本（用于准备数据），请求结束后执行的脚本（用于断言） 响应区： 响应内容： 可以查看Pretty（美化格式），Raw（原始格式），Preview（HTML预览格式） 响应Cookie 响应头 测试结果，对应请求中Tests中设置的断言Collection请求集测试集是Postman中接口管理的一个“整体”单位，运行、导出、分享等都是基于测试集的。 新建测试集： New按钮-&gt;Collection 或 直接点击测试集列表上方的新建测试集按钮 授权： 测试集及其子文件夹下的接口统一使用该授权，不用每个接口再都单独设置一遍 请求前脚本： 测试集的每个接口公用的请求前脚本 请求后断言： 测试集每个接口公用的请求后脚本 请求集变量： 请求集中公用的一些变量 子文件夹：子文件夹的属性中同样拥有描述，授权，请求前脚本，和请求后断言（没有变量，一个请求集的变量统一管理），实现了不同范围（Scope）的Fixture功能。 请求集导出：请求集可以导出并发送给别人（不携带环境信息），别人通过导入来使用你的接口 请求集分享： 请求集直接分享给别人（双方都需要注册） 环境管理 我们可以环境中设置多个变量，以供在请求中使用 环境变量使用方法： 选择环境，在请求URL或者请求Body里使用来使用环境变量 变量可以在请求Body的各种格式中使用 不能直接在请求前脚本（Pre-request Script）和请求后脚本（Tests）中使用 环境管理中还可以点击“Global”添加全局变量，环境变量只有当选择了该环境时生效，全局变量在任何环境中生效，测试集中的变量只在当前测试集生效，当测试集变量，环境变量，全局变量有重复的变量名时，优先级为：环境变量&gt;全局变量&gt;测试集变量 Params使用当请求URL中参数很多时，不方便进行添加和查看，可以点击Params按钮，以表格的方式添加变量及值，从表格添加后，变量和值会自动添加到URL中 请求设计 授权：如果接口需要授权，可以在该页面设置授权方式（type）和授权信息 Header: 请求头，可以设置请求类型（Content-Type）和Cookie Body: 请求数据 form-data：混合表单，支持上传文件 x-www-form-urlencoded：文本表单 raw：原始格式，支持JSON/XML格式（后面可选择） binary: 二进制格式，用于发送二进制数据流 Pre-request Script: 请求前脚本，Javascript语法，用于在发送请求前生成一些动态数据或做一些处理 Tests：请求后脚本，Javascript语法，用于请求返回后做一些处理或断言结果 Postman发送各种格式请求的方法：注意：选择不同的请求，会自动在Header中添加Content-Type信息 Tests断言一个Postman的test本质上是JavaScript的代码可以用来为一些特殊的test设置值。你可以在对象中设置一个描述性的键作为一个元素，然后声明他如果是true或false。tests[“Body contains user_id”] = responseBody.has(“user_id”)这回核对body中是否包含了user_id这个字符串。如果你需要，你可以增加更多的键，这取决于你要用test做多少的事情。 HTTP状态码断言: tests["HTTP状态码200"]=responseCode.code == 200; 响应包含内容断言： tests["状态码200"] = responseBody.has("登录成功"|"你已经登录，无需重复登录"); 接口样例POST https://demo.fastadmin.net/admin/index/login.html 用户名/密码： username:admin password:123456 JSON响应断言 var jsonData = JSON.parse(responseBody); //获取body中返回的所有参数tests["code为100000表示成功"] = jsonData.code == "100000" 接口样例 GET http://www.tuling123.com/openapi/api?key=ec961279f453459b9248f0aeb6600bbe&amp;info=你好 Postman尝试通过列出编辑器旁边常用的片段来简化过程。您可以选择要添加的代码段，并将相应的代码添加到测试编辑器中。 Runner: 测试集批量执行 支持设置迭代次数 支持加载csv或json类测试数据 操作方法：https://demo.fastadmin.net/admin/index/login.html接口 新建一个Collection，比如名称Demo2 填入URL：https://demo.fastadmin.net/admin/index/login.html， 选择POST方法 请求数据（Body）格式选x-www-form-urlecoded，请求数据填写username password ，这里使用了两个变量来做参数化 保存请求到Demo2中 在电脑上新建一个data.csv文件，第一行为变量名 点击Postman工具栏的Runner按钮，Collection选择Demo2， Data选择数据文件data.csv， 点击运行Demo2 环境变量的用法详解在postman中，可以利用tests将接口返回的response设置为环境变量，供后续接口使用（类似参数化的概念） var jsonData =JSON.parse(responseBody); //获取body中返回的所有参数postman.setEnvironmentVariable("appKey",jsonData.data.appKey);//把返回参数中的keys设置为环境变量var data = postman.getResponseHeader("Access-Token"); //获取响应头所有参数postman.setEnvironmentVariable("Access-Token",data); //把返回参数中的Access-Token设置为环境变量 postman常用方法集合https://learning.getpostman.com/docs/postman/scripts/test_examples/ 环境变量//设置环境变量pm.environment.set("variable_key", "variable_value");//将一个嵌套的对象设置为一个环境变量var array = [1, 2, 3, 4];pm.environment.set("array", JSON.stringify(array, null, 2)); var obj = &#123; a: [1, 2, 3, 4], b: &#123; c: 'val' &#125; &#125;;pm.environment.set("obj", JSON.stringify(obj)) //获取环境变量pm.environment.get("variable_key"); //获取环境变量（其值是字符串化对象)// 如果数据来自未知源，则应该将这些语句包装在try-catch块中var array = JSON.parse(pm.environment.get("array"));var obj = JSON.parse(pm.environment.get("obj"));//清除环境变量pm.environment.unset("variable_key"); //清除一个环境变量 全局变量pm.globals.set("variable_key", "variable_value"); //设置一个全局变量pm.globals.get("variable_key"); //获取一个全局变量pm.globals.unset("variable_key"); //清除一个全局变量 获取一个变量该函数在全局变量和活动环境中搜索变量 pm.variables.get("variable_key"); 检查response body中是否包含某个stringtests["Body matches string"] = responseBody.has("string_you_want_to_search");pm.test("Body matches string", function () &#123; pm.expect(pm.response.text()).to.include("string_you_want_to_search");&#125;); 检查response body是否与某个string相等tests["Body is correct"] = responseBody === "哈哈哈"; //必须完全匹配pm.test("Body is correct", function () &#123; pm.response.to.have.body("response_body_string");&#125;); 检测JSON中的某个值是否等于预期的值var data = JSON.parse(responseBody);tests["Your test name"] = data.value === 100;tests["状态码为301"] = data["status"] == "301";tests["message"] = data["message"] == "购买商品库存不足";tests["list"] = data["lists"][0] == "11";pm.test("Your test name", function () &#123; var jsonData = pm.response.json(); pm.expect(jsonData.value).to.eql(100);&#125;); JSON.parse()方法，把json字符串转化为对象。parse()会进行json格式的检查是一个安全的函数。如：检查json中某个数组元素的个数(这里检测programs的长度) var data = JSON.parse(responseBody);tests["program's lenght"] = data.programs.length === 5; 测试response Headers中的某个元素是否存在(如:Content-Type)//getResponseHeader()方法会返回header的值，如果该值存在的话tests["Content-Type is present"] = postman.getResponseHeader("Content-Type"); //不区分大小写tests["Content-Type is present"] = responseHeaders.hasOwnProperty("Content-Type"); //要区分大小写 pm.test("Content-Type is present", function () &#123; pm.response.to.have.header("Content-Type");&#125;); 验证响应时间小于xxx毫秒tests["Response time is less than 200ms"] = responseTime &lt; 200;pm.test("Response time is less than 200ms", function () &#123; pm.expect(pm.response.responseTime).to.be.below(200);&#125;); 响应时间在特定范围内（包含下限，上限不包括）tests["Response time is acceptable"] = _.inRange(responseTime, 100, 1001); 验证状态码的值为200tests["Status code is 200"] = responseCode.code === 200;pm.test("Status code is 200", function () &#123; pm.response.to.have.status(200);&#125;); 代码名包含一个字符串tests["Status code name has string"] = responseCode.name.has("Created");pm.test("Status code name has string", function () &#123; pm.response.to.have.status("Created");&#125;); 成功的POST请求状态代码tests["Successful POST request"] = responseCode.code === 201 || responseCode.code === 202;pm.test("Successful POST request", function () &#123; pm.expect(pm.response.code).to.be.oneOf([201,202]);&#125;); 使用TinyValidator获取JSON数据var schema = &#123; "items": &#123; "type": "boolean" &#125;&#125;;var data1 = [true, false];var data2 = [true, 123];pm.test('Schema is valid', function() &#123; pm.expect(tv4.validate(data1, schema)).to.be.true; pm.expect(tv4.validate(data2, schema)).to.be.true;&#125;);//data1和data2是测试数据，schema相当于验证json的规范 //示例中验证data1和data2中的value是否都是boolean类型 获取request值： data {object}: 这是一个用于请求的表单数据字典 (request.data[“key”]==”value”) headers {object}: 这是请求头的字典 (request.headers[“key”]==”value”) method {string}: GET/POST/PUT 等. url {string}: 请求的url var Json = JSON.parse(request.data); 假设requestBody中有”version”:”1.0”；这个值,如果想获取到version的value值，代码如下 var Json = JSON.parse(request.data); var version = Json["version"]; JSON.parse()和JSON.stringify()JSON.parse() //【从一个字符串中解析出json对象】--把string转对象JSON.stringify() //【从一个对象中解析出字符串，主要针对[object object]类型数据的转换】--把对象转Stringvar data=&#123;name:'goatling'&#125;JSON.parse(data)//结果是： '&#123;"name":"goatling"&#125;'JSON.stringify(data)//结果是：name:"goatling" 发送异步请求。此功能既可用作预请求脚本，也可用作测试脚本。pm.sendRequest("https://postman-echo.com/get", function (err, response) &#123; console.log(response.json());&#125;); 转换XML body为JSON对象var jsonObject = xml2Json(responseBody); 判断字段值是否为空typeof()var Jsondata = JSON.parse(responseBody);if( typeof(Jsondata.data) != "undefined" ) 分支和循环//设置下一个要执行的请求postman.setNextRequest("request_name");//停止工作流程执行postman.setNextRequest(null); postman.setNextRequest()一些重点： * 指定后续请求的名称或ID，集合运行器将负责其余的请求。 * 它可以用在预请求或测试脚本中。如果有多个赋值，则考虑最后一个赋值。 * 如果postman.setNextRequest()请求中不存在，则集合运行器默认为线性执行并移至下一个请求 服务端返回异常 Status Code：HTTP状态码 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 常见HTTP响应码 200：成功 301、302：请求重定向到另外一个接口 400：请求格式不对／服务端故意失败 403：禁止访问(被封禁／没有权限) 404：资源不存在（有可能是请求url错误或参数不正确） 405：请求方法不被允许（比如接口只允许Post,使用Get请求接口） 429：请求频率过高 500：服务器内部错误（通常是服务器挂了或接口Bug) 502、503：服务发布间隙没衔接好／挂了 504：网关请求超时（Bug，挂了） 409、406：正常返回，不应该被记录]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac电脑用终端生成SSH key 访问自己的Github]]></title>
    <url>%2F2019%2F05%2F21%2FMac%E7%94%B5%E8%84%91%E7%94%A8%E7%BB%88%E7%AB%AF%E7%94%9F%E6%88%90SSH%20key%20%E8%AE%BF%E9%97%AE%E8%87%AA%E5%B7%B1%E7%9A%84Github%2F</url>
    <content type="text"><![CDATA[首先检测自己电脑是否存在 SSH key在生成SSH密钥之前，您可以检查是否有任何现有的SSH密钥。 打开终端 输入ls -al ~/.ssh以查看是否存在现有SSH密钥： ls -al ~/.ssh# 列出.ssh目录中的文件(如果存在的话) 检查目录列表以查看您是否已拥有公共SSH密钥。 如果你本地没有生成的话 终端上面会显示：No such file or directory 如果已经存在的话， 则会显示 id_rsa 和 id_rsa.pub 如果本地没有的话，我们要自己生成新的SSH秘钥 开放式终端。 输入下面的命令，记得替换您的GitHub电子邮件地址。 ssh-keygen -t rsa -b 4096 -C "your_email@example.com"#"your_email@example.com"为示例邮箱，此处应填写为你在github上面注册的邮箱。 这将使用提供的电子邮件作为标签创建一个新的ssh密钥。 Generating public/private rsa key pair. 当系统提示您“输入要保存密钥的文件”时，按Enter键使用默认文件位置。 Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] 在提示符下，键入安全密码。可以连续Enter，不设置密码。 Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 成功后，终端显示 Your identitification has been saved in /Users/xxx/.ssh/id_rsa.Your public key has been saved in /user/xxx/id_rsa.pub.the key fingerprint is xxxxxxxxxx…….xxxxxxxx your_email@example.comThe key’s randomart image is: 将SSH密钥添加到ssh-agent 在后台启动ssh-agent eval "$(ssh-agent -s)"&gt; Agent pid 59566 终端输入命令： ssh-add -K ~/.ssh/id_rsa 如果设置密码，此时会要求输入passphrase（输入步骤 二 中的 passphrase就好 ） 成功后，中选显示： Identity added: /Users/xxx/.ssh/id_rsa (your_email@example.com) 添加SSH key 到Github 上 将SSH密钥复制到剪贴板。 pbcopy &lt; ~/.ssh/id_rsa.pub# 复制id_rsa.pub的内容到剪贴板 提示：如果pbcopy不起作用，您可以找到隐藏.ssh文件夹，在文本编辑器中打开id_rsa.pub文件，然后将文件内容复制到剪贴板。 在任意页面的右上角，单击您的个人资料照片，然后单击“Settings”。 在用户设置侧栏中，单击“SSH and GPG keys”。 单击“ New SSH key” 在“Title”字段中添加描述性标签，Key字段中粘贴您复制的id_rsa.pub内容。最后点击“Add SSH key” 最后请确认您的GitHub密码。 如何检测SSH key 终端输入命令：ssh git@github.com 验证SSH key是否有权限访问 你的 github，输入“yes” The authenticity of host ‘github.com (13.250.177.223)’ can’t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yes 成功会显示为 Hi you name! You’ve successfully authenticated, but GitHub does not provide shell access.]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libimobiledevice命令]]></title>
    <url>%2F2019%2F05%2F21%2Flibimobiledevice%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[简介A library to communicate with services of Apple iOS devices using native protocols. 命令 打印app列表 ideviceinstaller -l 查看当前已连接的设备的UUID idevice_id -l 获取设备信息 ideviceinfo 获取设备时间 idevicedate 重启设备 idevicediagnostics restart 安装ipa包，卸载应用 ideviceinstaller -i xxx.ipa//命令安装一个ipa文件到手机上，如果是企业签名的，非越狱机器也可以直接安装了。ideviceinstaller -U [bundleID]//命令卸载应用，需要知道此应用的bundleID 查看系统日志 idevicesyslog//屏幕上即可看见手机上所有的日志idevicesyslog &gt;&gt; iphone.log &amp;//该命令是将日志导入到iphone.log这个文件，并且是在后台执行。//然后用tail -f和grep查看logtail -f iphone.logtail -f iphone.log | grep 'WeChat’ # 查看包含WeChat的行 截图 idevicescreenshot//如果在使用截图的时候出现报错信息，那么就去把相应版本的DeveloperDiskImage的两个文件复制到libimobiledevice文件下面。路径：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/对应版本/获取版本号命令：ideviceinfo -k ProductVersion安装DeveloperDiskImage命令：ideviceimagemounter DeveloperDiskImage.dmg//然后就可以正常截图了 遇到报错 解决方法：卸载重装brew uninstall ideviceinstallerbrew uninstall libimobiledevicebrew install --HEAD libimobiledevicebrew install ideviceinstaller]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Ruby版本管理器RVM]]></title>
    <url>%2F2019%2F05%2F21%2FMac%E5%AE%89%E8%A3%85Ruby%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8RVM%2F</url>
    <content type="text"><![CDATA[简介RVM是一个命令行工具，它允许您轻松地安装，管理和使用从解释器到多组宝石的多个ruby环境。 安装Ruby原因虽然 macOS 自带了一个 ruby 环境，但是是系统自己使用的，所以权限很小，只有 system。而/Library 目录是 root 权限,所以很多会提示无权限。 安装RVM 安装mpapis公钥。但是，正如安装页面所记录的，您可能需要gpg。Mac OS X不附带gpg，因此在安装公钥之前，您需要安装gpg。 Homebrew安装gpg ： brew install gnupg 安装完gpg之后，你可以安装mpapis公钥： gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB 安装最新版本的Ruby的RVM \curl -sSL https://get.rvm.io | bash -s stable 安装完载入 RVM 环境： source ~/.rvm/scripts/rvm 检查版本 rvm -v （如果想卸载RVM，执行以下命令） rvm implode 使用RVM&amp;Rubyruby rvm 常用指令ruby -v # 查看ruby 版本rvm list known # 列出已知的 ruby 版本rvm install 2.3.0 # 选择指定 ruby 版本进行更新rvm get stable # 更新 rvmrvm use 2.2.2 # 切换到指定 ruby 版本rvm use 2.2.2 --default # 设置指定 ruby 版本为默认版本rvm list # 查询已安装的 ruby 版本rvm remove 1.9.2 # 卸载移除 指定 ruby 版本rvm uninstall 2.0.0rvm system #使用系统ruby(就像没有rvm一样)curl -L https://get.rvm.io | bash -s stable # 安装 rvm 环境curl -sSL https://get.rvm.io | bash -s stable --ruby # 默认安装 rvm 最新版本curl -sSL https://get.rvm.io | bash -s stable --ruby=2.3.0 # 安装 rvm 指定版本source ~/.rvm/scripts/rvm # 载入 rvm Gem常用指令gem -v # 查看 gem 版本gem source # 查看 gem 配置源gem source -l # 查看 gem 配置源目录gem sources -a url # 添加 gem 配置源（url 需换成网址）gem sources --add url # 添加 gem 配置源（url 需换成网址）gem sources -r url # 删除 gem 配置源（url 需换成网址）gem sources --remove url # 删除 gem 配置源（url 需换成网址）gem update # 更新 所有包gem update --system # 更新 Ruby Gems 软件gem install rake # 安装 rake，从本地或远程服务器gem install rake --remote # 安装 rake，从远程服务器gem install watir -v 1.6.2 # 安装 指定版本的 watirgem install watir --version 1.6.2 # 安装 指定版本的 watirgem uninstall rake # 卸载 rake 包gem list d # 列出 本地以 d 打头的包gem query -n ''[0-9]'' --local # 查找 本地含有数字的包gem search log --both # 查找 从本地和远程服务器上查找含有 log 字符串的包gem search log --remoter # 查找 只从远程服务器上查找含有 log 字符串的包gem search -r log # 查找 只从远程服务器上查找含有log字符串的包gem help # 提醒式的帮助gem help install # 列出 install 命令 帮助gem help examples # 列出 gem 命令使用一些例子gem build rake.gemspec # 把 rake.gemspec 编译成 rake.gemgem check -v pkg/rake-0.4.0.gem # 检测 rake 是否有效gem cleanup # 清除 所有包旧版本，保留最新版本gem contents rake # 显示 rake 包中所包含的文件gem dependency rails -v 0.10.1 # 列出 与 rails 相互依赖的包gem environment # 查看 gem 的环境sudo gem -v # 查看 gem 版本（以管理员权限）sudo gem install cocoa pods # 安装 CocoaPods（以管理员权限）sudo gem install cocoapods # 安装 CocoaPods（以管理员权限）sudo gem install cocoapods --pre # 安装 CocoaPods 至预览版（以管理员权限）sudo gem install cocoapods -v 0.39.0 # 安装 CocoaPods 指定版本（以管理员权限）sudo gem update cocoapods # 更新 CocoaPods 至最新版（以管理员权限）sudo gem update cocoapods --pre # 更新 CocoaPods 至预览版（以管理员权限）sudo gem uninstall cocoapods -v 0.39.0 # 移除 CocoaPods 指定版本（以管理员权限） pod常用指令pod setup # CocoaPods 将信息下载到~/.cocoapods/repos 目录下。如果安装 CocoaPods 时不执行此命令，在初次执行 pod intall 命令时，系统也会自动执行该指令pod --version # 检查 CocoaPods 是否安装成功及其版本号pod install # 安装 CocoaPods 的配置文件 Podfile]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（Mac）iOS自动化打包（Jenkins+fastlane+pgy]]></title>
    <url>%2F2019%2F05%2F21%2F%EF%BC%88Mac%EF%BC%89iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%EF%BC%88Jenkins-fastlane-pgy%2F</url>
    <content type="text"><![CDATA[环境 名称 版本 macOS 10.14.4 (18E226) Xcode Version 10.2.1 ruby 2.6.3 fastlane 2.123.0 Fastlane安装Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。安装过程如下 安装ruby（brew安装最新版）#直接在终端执行，未安装brew，先安装brew #安装最新的2.6.3brew install ruby #安装完根据提示执行echo 'export PATH="/usr/local/opt/ruby/bin:$PATH"' &gt;&gt; ~/.zshrc #退出终端查看ruby版本ruby -v #检查安装路径which -a ruby 更改gem源 更改 gem sources --remove https://rubygems.org/gem sources --add https://gems.ruby-china.com/ 查看 gem sources -l 如果是以下结果说明正确，如果有其他的请自行百度解决 *** CURRENT SOURCES ***https://gems.ruby-china.com/ 安装fastlane #安装gem install -n /usr/local/bin fastlane -NV#检查是否安装成fastlane --version 至此，我们已经可以使用fastlane自动化打包了 Fastlane配置fastlane initcd 到工程主目录执行fastlane init我这里选择的是手动配置cd /Users/vic/.jenkins/workspace/jike-iOS-Fastlanfastlane init 会在你项目工程的目录下生成一个fastlane文件夹，里面有Fastlane的配置文件，一个是Appfile文件(保存了苹果开发者的相关信息)，一个是Fastfile文件（运行脚本） 编辑Fastfile文件（运行脚本）有时候一天需要打好几个包，为了区分，我们这里实现一个递增build号的功能。 定义一个递增build号的函数，添加到Fastfile中 def updateProjectBuildNumbercurrentTime = Time.new.strftime("%Y%m%d")build = get_build_number()if build.include?"#&#123;currentTime&#125;."# =&gt; 为当天版本 计算迭代版本号lastStr = build[build.length-2..build.length-1]lastNum = lastStr.to_ilastNum = lastNum + 1lastStr = lastNum.to_sif lastNum &lt; 10lastStr = lastStr.insert(0,"0")endbuild = "#&#123;currentTime&#125;.#&#123;lastStr&#125;"else# =&gt; 非当天版本 build 号重置build = "#&#123;currentTime&#125;.01"endputs("*************| 更新build #&#123;build&#125; |*************")# =&gt; 更改项目 build 号increment_build_number(build_number: "#&#123;build&#125;")end 实现自动打包的完整Fastfile如下: # 定义fastlane版本号fastlane_version "2.123.0"# 定义打包平台default_platform :iosdef updateProjectBuildNumbercurrentTime = Time.new.strftime("%Y%m%d")build = get_build_number()if build.include?"#&#123;currentTime&#125;."# =&gt; 为当天版本 计算迭代版本号lastStr = build[build.length-2..build.length-1]lastNum = lastStr.to_ilastNum = lastNum + 1lastStr = lastNum.to_sif lastNum &lt; 10lastStr = lastStr.insert(0,"0")endbuild = "#&#123;currentTime&#125;.#&#123;lastStr&#125;"else# =&gt; 非当天版本 build 号重置build = "#&#123;currentTime&#125;.01"endputs("*************| 更新build #&#123;build&#125; |*************")# =&gt; 更改项目 build 号increment_build_number(build_number: "#&#123;build&#125;")end#指定项目的scheme名称scheme="Ruguo"#蒲公英api_key和user_keyapi_key="8e860ee5ba4996f9b19e56c28e07846a"user_key="542e73b113b5908da8b028805bf7e837"# 任务脚本platform :ios dolane :development_build do|options|branch = options[:branch]puts "开始打development ipa"updateProjectBuildNumber #更改项目build号# 开始打包gym(#指定需要编译的schemescheme:"#&#123;scheme&#125;",#输出的ipa名称output_name:"#&#123;scheme&#125;_#&#123;get_build_number()&#125;",# 是否清空以前的编译信息 true：是clean:true,# 指定打包方式，Release 或者 Debugconfiguration:"Release",# 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, developmentexport_method:"development",# 指定输出文件夹output_directory:"./fastlane/build",)#puts "开始上传蒲公英"# 开始上传蒲公英#pgyer(api_key: "#&#123;api_key&#125;", user_key: "#&#123;user_key&#125;", password: "alpha", install_type: "2")endend 注意：蒲公英的 api_key 和 user_key，开发者在自己账号下的 账号设置-API信息 中可以找到。打其它类型的包的方法与development类似，可自定义一个新的lane实现。 自动打包并上传蒲公英，在终端输入便会进行自动打包并上传蒲公英了。 fastlane development_build Jenkins安装下载安装Jenkins。具体安装过程可参考 Mac Jenkins搭建 Jenkins配置 点击新建，输入名称，构建一个自由风格的软件项目 添加Git仓库地址，可以是HTTP也可以是SSH。点击Add 构建，点击“添加构建步骤”，选择Execute shell。 export PATH=/usr/local/bin:$PATHfastlane development_buildfilepath=`pwd`fastlane/build/Ruguo*.apifile=`ls $filepath`if [ $uploadPgy = true ]then curl -F "installType=2" -F "password=alpha" -F "file=@$file" -F "uKey=542e73b113b5908da8b028805bf7e837" -F "_api_key=8e860ee5ba4996f9b19e56c28e07846a" https://qiniu-storage.pgyer.com/apiv1/app/uploadfi 添加完成之后保存，点击立即构建]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（Mac）iOS自动化打包（Jenkins+xcodebuild+fir）]]></title>
    <url>%2F2019%2F05%2F21%2F%EF%BC%88Mac%EF%BC%89iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%EF%BC%88Jenkins-xcodebuild-fir%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境 名称 版本 macOS 10.14.4 (18E226) Xcode Version 10.2.1 ruby 2.6.3 fir-cli 1.7.1 下载安装Jenkins Jenkins是基于Java环境的，所以电脑上必须先安装Java，Jenkins官网（https://jenkins.io） 下载安装Jenkins。具体安装过程可参考 Mac Jenkins搭建 安装完成后会自动打开http://localhost:8080这个网址，如果没有自动打开可以手动打开。有些教程还有添加Xcode integration 、Keychains and Provisioning Profiles Plugin之类插件的步骤，我们不需要。因为我们是用xcode脚本构建，所以不需要安装任何插件。 新建任务构建一个自由风格的软件项目点击左侧菜单中的新建任务,然后在新的界面输入项目名字,选择构建一个自由风格的软件项目选项完成创建 填写工程相关介绍 源码管理 源码管理，使用github选择git 构建触发器 选择Build periodically，输入： H 2 * * * 周期性的执行编译任务，强制每天凌晨两点构建一次 选择Poll SCM，输入 H/5 * * * * 表示的就是每5分钟检查一次源码变化。 第一个参数代表的是分钟 minute，取值 0~59； 第二个参数代表的是小时 hour，取值 0~23； 第三个参数代表的是天 day，取值 1~31； 第四个参数代表的是月 month，取值 1~12； 最后一个参数代表的是星期 week，取值 0~7，0 和 7 都是表示星期天。 构建环境 通过xcodebuild脚本的方式构建，这里不用做任何设置。 构建重点来了。点击“添加构建步骤”，选择Execute shell。 #!/bin/sh +xxcodebuild clean -workspace /Users/vic/.jenkins/workspace/jike-iOS/Ruguo.xcworkspace \ -scheme Ruguo \xcodebuild archive -workspace /Users/vic/.jenkins/workspace/jike-iOS/Ruguo.xcworkspace \ -scheme Ruguo \ -archivePath "$WORKSPACE/Ruguo.xcarchive" \ -configuration Debug \xcodebuild -exportArchive -archivePath "$WORKSPACE/Ruguo.xcarchive" \ -exportPath "$WORKSPACE/Export/Ruguo" \ -exportOptionsPlist "$WORKSPACE/ExportOptions.plist" \ -configuration Debug \export PATH=/usr/local/bin:$PATHfir publish /Users/vic/.jenkins/workspace/jike-iOS/Export/Ruguo/Ruguo.ipa -T 4554bab16fc50b5b8ee20d9663fa64c7 --password=jikebeta 说明：-archivePath：.xcarchive文件的存放路径。-exportPath：导出文件的路径。Export文件夹是自己建的。-ExportOptions.plist：这个文件的内容其实是ipa的打包信息。手动archive并export时，这个文件就包含在最终输出的文件夹内，可以copy一份出来使用。-configuration ：默认Debug或Release。这里有个坑要说明一下。archive和ipa文件的导出目录最好位于Jenkins用户下的那个工程中，我之前选择的是导出到当前用户的桌面，结果一直报读写权限的问题。 上传到fir要实现自动上传到fir，要先安装fir-clifir-cli由ruby实现，所以先安装ruby 安装ruby，ruby官网安装文档（我使用了brew安装） #直接在终端执行，未安装brew，先安装brew#安装最新的2.6.3brew install ruby #安装完根据提示执行echo 'export PATH="/usr/local/opt/ruby/bin:$PATH"' &gt;&gt; ~/.zshrc #退出终端查看ruby版本ruby -v #检查安装路径which -a ruby 安装fir-cli。要实现自动上传到fir，要先安装fir-cli。Github: fir-cli gem install -n /usr/local/bin fir-cli fir token查看方法： 脚本 fir publish /Users/vic/.jenkins/workspace/jike-iOS/Export/Ruguo/Ruguo.ipa -T 4554bab16fc50b5b8ee20d9663fa64c7 --password=jikebeta]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（Mac）Android自动打包（Jenkins+Gradle+pgy）]]></title>
    <url>%2F2019%2F05%2F21%2F%EF%BC%88Mac%EF%BC%89Android%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%EF%BC%88Jenkins-Gradle-pgy%EF%BC%89%2F</url>
    <content type="text"><![CDATA[准备环境配置Android ADB环境关于Android整个开发环境的搭建，SDK的下载安装这里就不赘述了，配置adb环境可以参考、 这里查看adb是否配置成功可以在终端输入adb version 显示以下信息则证明配置成功Android Debug Bridge version 1.0.41Version 28.0.3-5475833Installed as /Users/vic/Library/Android/sdk/platform-tools/adb 配置Gradle环境配置gradle环境可以看一下我之前写的这篇文章Mac 配置gradle环境变量. 这里查看gradle是否配置成功可以在终端输入gradle -version 显示如下信息则表示配置成功 下载安装Jenkins这里有两种方法可以用。参考Mac下Jenkins搭建 Jenkins环境变量的配置左侧系统管理-&gt;系统设置，进入系统设置页面全局属性下的环境变量，添加键值对 左侧系统管理-&gt;全局工具设置，进入全局工具设置页面1. JDK JDK installations一栏里面点击Add JDK，Name随便取，不过最好对应好版本号；JAVE_HOME就设置为当前Mac下Java的安装路径。当然也可以设置成自动安装 2. Gradle gradle配置：一样名字最好跟着版本号，GRADLE_HOME就设置为gradle的安装目录 项目配置构建一个自由风格的软件项目点击左侧菜单中的新建任务,然后在新的界面输入项目名字,选择构建一个自由风格的软件项目选项完成创建 项目基本配置点击左边的配置，从上到下一共6个tab，我们去一一配置自己想要的功能： General 描述里面我们可以写工程简介 “This project is parameterized”参数化构建 “Discard old builds”丢弃旧的仓库 源码管理 源码管理，使用github选择git，使用svn选择subversion 点击add以后，进入选择身份验证的页面，没有ssh key的，选择用户名和密码，有ssh key的选择ssh验证（注意，这里填写的是private key，id_rsa文件中的key，不是id_rsa.pub中的key），填写完成后，点击add即可完成身份验证的添加。然后选择对应的身份验证 项目的分支，填写你需要的分支 构建触发器 选择Build periodically，输入：H 2 * * * 周期性的执行编译任务，强制每天凌晨两点构建一次 选择Poll SCM，输入H/5 * * * * 表示的就是每5分钟检查一次源码变化。 &gt; 第一个参数代表的是分钟 minute，取值 0~59； &gt; 第二个参数代表的是小时 hour，取值 0~23； &gt; 第三个参数代表的是天 day，取值 1~31； &gt; 第四个参数代表的是月 month，取值 1~12； &gt; 最后一个参数代表的是星期 week，取值 0~7，0 和 7 都是表示星期天。 构建环境这里可以设置一些项目信息，比如在构建之前删除工作目录，设置构建名称等等。。。（但是我没有设置） 构建 增加构建步骤，选择Invoke Gradle script（编译） Gradle选择你配置的版本 Task中填写构建执行的语句（注意：不要选择Use Gradle Wrapper），一般要填写“clean assembleRelease”。先clean再build cleanassembleReleaseChannels -PchannelFile=markets.txt 在Root Build script中输入你想要包生成的位置，在Build File中输入项目的build.gradle的路径。即在Root Build script路径的后边加/build.gradle，可以不输入这两项，项目会有个默认构建地址，具体地址可以再jenkins的系统管理中查看。 继续添加构建步骤，选择“Execute shell”，在command中填入（上传蒲公英） ./gitswitch dev/cicd Sourcefilepath=`pwd`/app/build/outputs/channels/*pgy*.apkfile=`ls $filepath`if [ $uploadPgy = true ]then curl -F "installType=2" -F "password=alpha" -F "file=@$file" -F "uKey=542e73b113b5908da8b028805bf7e837" -F "_api_key=8e860ee5ba4996f9b19e56c28e07846a" https://qiniu-storage.pgyer.com/apiv1/app/uploadfi 构建后操作Archive the artifacts（归档成品），输入内容**/app/build/outputs/channels/*.apk, **/apk-checker-result.* 上传蒲公英增加一个构建步骤，选择Execute shell，在command中填入./gitswitch dev/cicd Sourcefilepath=`pwd`/app/build/outputs/channels/*pgy*.apkfile=`ls $filepath`if [ $uploadPgy = true ]then curl -F "installType=2" -F "password=alpha" -F "file=@$file" -F "uKey=542e73b113b5908da8b028805bf7e837" -F "_api_key=8e860ee5ba4996f9b19e56c28e07846a" https://qiniu-storage.pgyer.com/apiv1/app/uploadfi 蒲公英官方文档地址https://www.pgyer.com/doc/api#uploadApp 调试构建历史-&gt;控制台输出，可以查看构建日志，根据报错来具体定位问题]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Jenkins搭建]]></title>
    <url>%2F2019%2F05%2F21%2FMac%E4%B8%8BJenkins%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Mac Jenkins搭建这里有两种方法可以用。第一种操作方便，可以直接下载安装包，但是安装包会有一些莫名的问题。第二种操作繁琐一点，需要操作命令行，直接命令行安装： 直接登录官网下载安装：（不推荐）jenkins的官网下载地址：https://jenkins.io/download/因为这里是Mac下面所以需要选择MacOS的版本：(左边是稳定版本，右边是测试版本，所以一般都是选择左边的)下载完成以后直接点击安装就可以了。之后在浏览器输入链接：http://localhost:8080 就行 brew下载安装(推荐使用)： 安装安装brew（如果已安装跳过） /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 安装Jenkins brew install jenkins 查找jenkins war地址 #在安装后有可能找不到war包地址,可以用mdfind命令本地查询下mdfind -name jenkins.war#/usr/local/Cellar/jenkins/2.174/libexec/jenkins.war 启动 java -jar /usr/local/Cellar/jenkins/2.116/libexec/jenkins.war --httpPort=8080 后台启动 后台启动的意思是放到后台运行,即使窗口被干掉,jenkins的进程也会存在.简单用shell脚本nohup命令放到后台启动脚本命令:sh startjenkins.sh#!/bin/bashecho start jenkinsnohup java -jar /usr/local/Cellar/jenkins/2.116/libexec/jenkins.war --httpPort=8080 &amp;echo start end Jenkins的环境配置启动进入启动成功就可以在浏览器输入http://localhost:8080后可以通过红色路径找到文件打开查看密码，Mac下面路径这个/Users/你的Mac用户名/.jenkins/secrets/initialAdminPassword 密码： 插件安装输入密码进入插件安装的页面，分别是“安装建议的插件”和“选择插件进行安装”，这里我选择左侧的选项（“安装建议的插件”），然后等待自动安装完成如果提示install failure，右下角有个retry，重试一下就好了 创建第一个管理员账户填写完表格，点击save and finish，jenkins的初始配置就完成啦然后要重启一下，填入刚才输入的admin账号密码才能登录进去 jenkins常用操作访问:http://localhost:8080/login?from=%2F退出:http://localhost:8080/exit 重启:http://localhost:8080/restart 重新加载:http://localhost:8080/reload#如果你不想/不需要后台服务，你可以运行:brew services start jenkins]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIAutomator2的使用]]></title>
    <url>%2F2019%2F05%2F20%2FUIAutomator2%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简介uiautomator2是一个python库，用于Android的UI自动化测试，其底层基于Google uiautomator，Google提供的uiautomator库可以获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作 支持平台及语言你在python-uiautomator2封装了谷歌自带的uiautomator2测试框架，提供便利的python接口。他允许测试人员直接在PC上编写Python的测试代码，操作手机应用，完成自动化，大大提高了自动化代码编写的效率。 工作原理如图所示，python-uiautomator2主要分为两个部分，python客户端，移动设备 python端: 运行脚本，并向移动设备发送HTTP请求 移动设备：移动设备上运行了封装了uiautomator2的HTTP服务，解析收到的请求，并转化成uiautomator2的代码。 整个过程 在移动设备上安装atx-agent(守护进程), 随后atx-agent启动uiautomator2服务(默认7912端口)进行监听 在PC上编写测试脚本并执行（相当于发送HTTP请求到移动设备的server端） 移动设备通过WIFI或USB接收到PC上发来的HTTP请求，执行制定的操作 安装安装adb如命令行可以执行adb devices，则跳过此步骤从谷歌官网下载Android Platform Tools https://developer.android.com/studio/releases/platform-tools.html， 解压，并加包含adb.exe的目录加入到系统的PATH中。 安装uiautomator2pip install --upgrade --pre uiautomator2 如果你需要用到截图，安装pillowpip install pillow 设备安装atx-agent首先设备连接到PC，并能够adb devices发现该设备。执行下面的命令会自动安装本库所需要的设备端程序：uiautomator-server，atx-agent，openstf / minicap，openstf / minitouch # init就是所有USB连接电脑的手机上都安装uiautomator2python -m uiautomator2 init # 指定手机安装uiautomator2， 用 --mirrorpython -m uiautomator2 init --mirror --serial $SERIAL# 嫌弃慢的话，可以用国内的镜像python -m uiautomator2 init --mirror 最后提示success，代表atx-agent初始化成功。 安装weditor有了这个，方便我们快速的识别手机上的元素，方便写代码pip install --pre -U weditor#pip install --pre weditor Windows系统可以使用命令在桌面创建一个快捷方式 python -m weditor –shortcut 启动方法：python -m weditor 浏览器会自动打开一个网页 http://atx.open.netease.com，看到如下界面 重点说下这个部分如何与手机连接起来呢？就是通过手机序列号或IP来实现的。打开cmd,输入adb devices，查看手机序列号，输入框中填写设备的IP或者设备的Serial（序列号）。之后点击Connect，如果一切正常就会出现一个绿色的叶子点击蓝色的Reload，就可以在网页上看到手机的界面了。非常的强大。我们可以看到手机元素的各种定位方法，在UI自动化写代码的时候，真的是非常的方面，手机页面和weditor是实时同步的。 【推荐】AppetizerIO 所见即所得脚本编辑器AppetizerIO 提供了对uiautomator2的深度集成，可以图形化管理ATX设备，还有所见即所得脚本编辑器 *到网站下载直接打开，首次使用需要注册账号 * `设备管理` 界面里可以检查设备是否正常init，起停atx-agent，抓取atx-agent.log文件 * `APP测试-&gt;脚本助手`调出脚本助手，实时界面同步，点击界面直接插入各种代码，同时支持uiautomator和Appium * **[视频教程 请戳这里](https://github.com/openatx/uiautomator2/wiki/Appetizer%E6%89%80%E8%A7%81%E5%8D%B3%E6%89%80%E5%BE%97u2%E8%84%9A%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8)** [其他文档在此](http://doc.appetizer.io) 应用及操作调用uiautomator2的过程 配置手机设备参数，设置具体操作的是哪一台手机 抓取手机上应用的控件，制定对应的控件来进行操作 抓取手机上应用的控件，制定对应的控件来进行操作抓取手机上应用的控件，制定对应的控件来进行操作对抓取到的控件进行操作，比如点击、填写参数等。 设备连接方法，有两种python-uiautomator2连接手机的方式有两种，一种是通过WIFI，另外一种是通过USB。两种方法各有优缺点。WIFI最便利的地方要数可以不用连接数据线，USB则可以用在PC和手机网络不在一个网段用不了的情况。 通过WiFi，假设设备IP 192.168.5.4和您的PC在同一网络中 import uiautomator2 as u2d = u2.connect('192.168.5.4') # WIFI链接设备。或者u2.connect_wifi('10.0.0.1') 通过USB， 假设设备序列是123456789F（见adb devices） import uiautomator2 as u2d = u2.connect('123456789F') # USB链接设备。或者u2.connect_usb('123456f')#d = u2.connect_usb()#当前只有一个设备时可以用这个 在没有参数的情况下调用u2.connect()， uiautomator2将从环境变量ANDROID_DEVICE_IP获取设备IP。如果这个环境变量是空的，uiautomator将返回connect_usb，您需要确保只有一个设备连接到计算机。 检查并维持设备端守护进程处于运行状态d.healthcheck() 停用UiAutomator的守护程序?d.service('uiautomator').stop() 打开调试开关d.debug = Trued.info'''返回12:32:47.182 $ curl -X POST -d '&#123;"jsonrpc": "2.0", "id": "b80d3a488580be1f3e9cb3e926175310", "method": "deviceInfo", "params": &#123;&#125;&#125;' 'http://127.0.0.1:54179/jsonrpc/0'12:32:47.225 Response &gt;&gt;&gt;&#123;"jsonrpc":"2.0","id":"b80d3a488580be1f3e9cb3e926175310","result":&#123;"currentPackageName":"com.android.mms","displayHeight":1920,"displayRotation":0,"displaySizeDpX":360,"displaySizeDpY":640,"displayWidth":1080,"productName":"odin","screenOn":true,"sdkInt":25,"naturalOrientation":true&#125;&#125;''' 安装应用，只能从URL安装d.app_install('http://some-domain.com/some.apk')#引号内为下载apk地址 启动应用d.app_start('com.ruguoapp.jike')#引号内为包名称 停止应用#相当于'am force-stop'强制停止应用d.app_stop('com.example.hello_world') #相当于'pm clear' 清空App数据d.app_clear('com.example.hello_world') 停止所有正在运行的应用程序# 停止所有d.app_stop_all()# 停止所有应用程序，除了com.examples.demod.app_stop_all(excludes=['com.examples.demo']) 跳过弹窗，禁止弹窗d.disable_popups（）#自动跳过弹出窗口 d.disable_popups（假）#禁用自动跳过弹出窗 SessionSession表示应用程序的生命周期。可用于启动应用，检测应用崩溃 启动和关闭应用程序 sess = d.session("com.netease.cloudmusic") # start 网易云音乐sess.close() # 停止网易云音乐 使用python with启动和关闭应用程序 with d.session("com.netease.cloudmusic") as sess: sess(text="Play").click() 链接正在运行的应用 sess = d.session（“ com.netease.cloudmusic ”，attach = True） 检测应用崩溃 # App正在运行时sess(text="Music").click() # 操作是正常的 # App崩溃时sess(text="Music").click() # 引发会话中断错误SessionBrokenError# session下的其他函数调用也会引发SessionBrokenError错误 # 检查会话是否正确。# 警告:函数名将来可能会更改sess.running() # True or False 获取设备信息 获取基本信息 d.info 以下是可能的输出： &#123; u'displayRotation': 0, u'displaySizeDpY': 640, u'displaySizeDpX': 360, u'currentPackageName': u'com.android.launcher', u'productName': u'takju', u'displayWidth': 720, u'sdkInt': 18, u'displayHeight': 1184, u'naturalOrientation': True&#125; 获取窗口大小 d.window_size()# 设备垂直输出示例: (1080, 1920)# 设备水平输出示例: (1920, 1080) 获取当前应用程序信息。对于某些android设备，输出可以为空(参见输出示例3) d.current_app()# 输出示例 1: &#123;'package': 'com.netease.example', 'activity': '.Client', 'pid': 23710&#125;# 输出示例 2: &#123;'package': 'com.ruguoapp.jike', 'activity': 'com.ruguoapp.jike.business.video.ui.activity.videolist.VideoListActivity'&#125;# 输出示例 3: &#123;'package': None, 'activity': None&#125; 获取设备序列号 d.serial# 输出示例: 74aAEDR428Z9 获取WIFI IP print(d.wlan_ip)#输出示例:10.0.0.1 获取详细的设备信息 print(d.device_info) 下面是一个可能的输出: &#123;'udid': '3578298f-b4:0b:44:e6:1f:90-OD103', 'version': '7.1.1', 'serial': '3578298f', 'brand': 'SMARTISAN', 'model': 'OD103', 'hwaddr': 'b4:0b:44:e6:1f:90', 'port': 7912, 'sdk': 25, 'agentVersion': 'dev', 'display': &#123;'width': 1080, 'height': 1920&#125;, 'battery': &#123;'acPowered': False, 'usbPowered': False, 'wirelessPowered': False, 'status': 3, 'health': 0, 'present': True, 'level': 99, 'scale': 100, 'voltage': 4316, 'temperature': 272, 'technology': 'Li-ion'&#125;, 'memory': &#123;'total': 3690280, 'around': '4 GB'&#125;, 'cpu': &#123;'cores': 8, 'hardware': 'Qualcomm Technologies, Inc MSM8953Pro'&#125;, 'presenceChangedAt': '0001-01-01T00:00:00Z', 'usingBeganAt': '0001-01-01T00:00:00Z'&#125; 获取应用信息d.app_info("com.examples.demo")# 会输出#&#123;# "mainActivity": "com.github.uiautomator.MainActivity",# "label": "ATX",# "versionName": "1.1.7",# "versionCode": 1001007,# "size":1760809#&#125;# 保存应用程序图标img = d.app_icon("com.examples.demo")img.save("icon.png") 推拉文件 将文件推送到设备 # push文件夹d.push("foo.txt", "/sdcard/")# push和重命名d.push("foo.txt", "/sdcard/bar.txt")# push fileobjwith open("foo.txt", 'rb') as f: d.push(f, "/sdcard/")# 推动和更改文件访问模式d.push("foo.sh", "/data/local/tmp/", mode=0o755) 从设备中拉出一个文件 d.pull("/sdcard/tmp.txt", "tmp.txt")# 如果在设备上找不到文件，FileNotFoundError将引发d.pull("/sdcard/some-file-not-exists.txt", "tmp.txt") 关键事件 打开/关闭屏幕 d.screen_on（）＃打开屏幕 d.screen_off（）＃关闭屏幕 获取当前屏幕状态 d.info.get（' screenOn '）#需要 Android&gt; = 4.4 硬键盘和软键盘操作 d.press("home") # 点击home键d.press("back") # 点击back键d.press("left") # 点击左键d.press("right") # 点击右键d.press("up") # 点击上键d.press("down") # 点击下键d.press("center") # 点击选中d.press("menu") # 点击menu按键d.press("search") # 点击搜索按键d.press("enter") # 点击enter键d.press("delete") # 点击删除按键d.press("recent") # 点击近期活动按键d.press("volume_up") # 音量+d.press("volume_down") # 音量-d.press("volume_mute") # 静音d.press("camera") # 相机d.press("power") #电源键 你可以在 Android KeyEvnet上找到所有的关键代码定义 解锁屏幕 d.unlock()# 相当于# 1. 发射活动:com.github.uiautomator.ACTION_IDENTIFY# 2. 按home键 手势与设备的交互 单击屏幕 d.click（x，y） 双击屏幕 d.double_click（x，y）d.double_click（X，Y，0.1）＃默认两个单击之间间隔时间为0.1秒 长按 d.long_click（x，y）d.long_click（X，Y，0.5）#长按0.5秒（默认） 滑动 d.swipe(sx, sy, ex, ey)d.swipe(sx, sy, ex, ey, 0.5) #滑动0.5s(default) 拖动 d.drag(sx, sy, ex, ey)d.drag(sx, sy, ex, ey, 0.5)#拖动0.5s(default) 滑动点 多用于九宫格解锁，提前获取到每个点的相对坐标（这里支持百分比）， 更详细的使用参考这个帖子 使用u2实现九宫图案解锁 #从点(x0, y0)滑到点(x1, y1)再滑到点(x2, y2)#两点之间的滑动速度是0.2秒d.swipe((x0, y0), (x1, y1), (x2, y2), 0.2) 注意：单击，滑动，拖动操作支持百分比位置值。例： d.long_click(0.5, 0.5) 表示长按屏幕中心 屏幕相关的 检索方向 d.orientation# 检索方向。输出可以是 "natural" or "left" or "right" or "upsidedown" 设置方向 d.set_orientation('l') # or "left"d.set_orientation("l") # or "left"d.set_orientation("r") # or "right"d.set_orientation("n") # or "natural" 冻结/ 开启旋转 d.freeze_rotation()# 冻结旋转d.freeze_rotation(False)# 开启旋转 截图 # 截图并保存到电脑上的一个文件中，需要Android&gt;=4.2。d.screenshot("home.jpg") # 得到PIL.Image格式的图像. 但你必须先安装pillowimage = d.screenshot() # default format="pillow"image.save("home.jpg") # 或'home.png'，目前只支持png 和 jpg格式的图像 # 得到OpenCV的格式图像。当然，你需要numpy和cv2安装第一个import cv2image = d.screenshot(format='opencv')cv2.imwrite('home.jpg', image) # 获取原始JPEG数据imagebin = d.screenshot(format='raw')open("some.jpg", "wb").write(imagebin) 转储UI层次结构 # get the UI hierarchy dump content (unicoded).（获取UI层次结构转储内容）d.dump_hierarchy() 打开通知或快速设置 d.open_notification（）#下拉打开通知栏d.open_quick_settings（）#下拉打开快速设置栏 选择Ui对象选择器是一种方便的机制，用于在当前窗口中标识特定的UI对象。#选择带有文本'Clock'的对象，它的类名是'android.widget.TextView'd(text='Clock', className='android.widget.TextView') 选择器支持以下参数。有关详细信息，请参阅 UiSelector Java doc for detailed information. text, textContains, textMatches, textStartsWith className, classNameMatches description, descriptionContains, descriptionMatches, descriptionStartsWith checkable, checked, clickable, longClickable scrollable, enabled,focusable, focused, selected packageName, packageNameMatches resourceId, resourceIdMatches index, instance ##获取所选ui对象状态及其信息 检查特定的UI对象是否存在 d(text="Settings").exists # 返回布尔值，如果存在则为True，否则为Falsed.exists(text="Settings") # 另一种写法#高级用法d(text="Settings").exists(timeout=3) # 等待'Settings'在3秒钟出现 获取特定UI对象的信息 d(text="Settings").info 下面是一个可能的输出 &#123; 'bounds': &#123; 'bottom': 2744, 'left': 386, 'right': 478, 'top': 2679&#125;, 'childCount': 0, 'className': 'android.widget.TextView', 'contentDescription': None, 'packageName': 'com.ruguoapp.jike', 'resourceName': 'com.ruguoapp.jike:id/tv_main_tab_title', 'text': '动态', 'visibleBounds': &#123; 'bottom': 2744, 'left': 386, 'right': 478, 'top': 2679&#125;, 'checkable': False, 'checked': False, 'clickable': False, 'enabled': True, 'focusable': False, 'focused': False, 'longClickable': False, 'scrollable': False, 'selected': False&#125; 获取/设置/清除可编辑字段的文本(例如EditText小部件) d(text="Settings").get_text() #得到文本小部件d(text="Settings").set_text("My text...") #设置文本d(text="Settings").clear_text() #清除文本 获取Widget中心点 d(text="Settings").center()#d(text="Settings").center(offset=(0, 0)) # 基准位置左前 对选定UI对象的操作 UI对象有五种定位方式 text、resourceId、description、className、xpath、坐标 执行单击UI对象 #text定位单击d(text="Settings").click()d(text="Settings", className="android.widget.TextView").click()#resourceId定位单击d(resourceId="com.ruguoapp.jike:id/tv_title", className="android.widget.TextView").click() #description定位单击d(description="设置").click()d(description="设置", className="android.widget.TextView").click()#className定位单击d(className="android.widget.TextView").click()#xpath定位单击d.xpath("//android.widget.FrameLayout[@index='0']/android.widget.LinearLayout[@index='0']").click()#坐标单击d.click(182, 1264) # 等待元素出现(最多10秒），出现后单击 d(text="Settings").click(timeout=10)# 在10秒时点击，默认的超时0d(text='Skip').click_exists(timeout=10.0)# 单击直到元素消失，返回布尔d(text="Skip").click_gone(maxretry=10, interval=1.0) # maxretry默认值10,interval默认值1.0# 点击基准位置偏移d(text="Settings").click(offset=(0.5, 0.5)) # 点击中心位置，同d(text="Settings").click()d(text="Settings").click(offset=(0, 0)) # 点击左前位置d(text="Settings").click(offset=(1, 1)) # 点击右下 执行双击UI对象 d(text="设置").double_click() #双击特定ui对象的中心d.double_click(x, y, 0.1)#两次单击之间的默认持续时间为0.1秒 执行长按UI对象 # 长按特定UI对象的中心d(text="Settings").long_click()d.long_click(x, y, 0.5) # 长按坐标位置0.5s默认 ##特定UI对象的手势操作 将UI对象拖向另一个点或另一个UI对象 # Android&lt;4.3不能使用drag.# 在0.5秒内将UI对象拖到屏幕点(x, y)d(text="Settings").drag_to(x, y, duration=0.5)# 将UI对象拖到另一个UI对象的中心位置，时间为0.25秒d(text="Settings").drag_to(text="Clock", duration=0.25) ==未懂==从UI对象的中心向其边缘滑动 滑动支持4个方向:左、右、上、下 d(text="Settings").swipe("right") d(text="Settings").swipe("left", steps=10) d(text="Settings").swipe("up", steps=20) # 1步约为5ms, 20步约为0.1s d(text="Settings").swipe("down", steps=20) ``` - ==未懂==两点手势操作，从一个点到另一个点```pythond(text="Settings").gesture((sx1, sy1), (sx2, sy2), (ex1, ey1), (ex2, ey2)) 特定UI对象的手势操作 支持两种手势：从边缘到中心、从中心到边缘 #注意:缩放要到安卓4.3才能设置。#从边缘到中心d(text="Settings").pinch_in(percent=100, steps=10)# 从中心到边缘d(text="Settings").pinch_out() 等待，直到特定的UI出现或消失 # 等待ui对象出现d(text="Settings").wait(timeout=3.0) # 返回布尔值# 等待ui对象的消失d(text="Settings").wait_gone(timeout=1.0) 默认超时为20秒。有关详细信息，请参阅全局设置 ==未懂==对特定的ui对象执行投掷(可滚动) 可能的属性 horiz（水平） 或 vert（垂直） forward（向前）或backward（向后）或toBeginning（开始位置）或toEnd（结束位置）#向前投掷(默认)垂直(默认)d(scrollable=True).fling()#垂直向后滚动d(scrollable=True).fling.vert.forward()#没搞懂d(scrollable=True).fling.vert.backward()#没搞懂d(scrollable=True).fling.horiz.toBeginning(max_swipes=1000)#滚动到结束d(scrollable=True).fling.toEnd() ==未懂==在特定的ui对象上执行滚动(可滚动) 可能的属性 horiz（水平） 或 vert（垂直） forward（向前）或backward（向后）或toBeginning（开始位置）或toEnd（结束位置）或 to 来# 向前滚动(默认)垂直(默认)d(scrollable=True).scroll(steps=10)# 水平向前滚动d(scrollable=True).scroll.horiz.forward(steps=100)#垂直向后滚动d(scrollable=True).scroll.vert.backward()#滚动到开始水平d(scrollable=True).scroll.horiz.toBeginning(steps=100, max_swipes=1000)# 滚动到垂直结束d(scrollable=True).scroll.toEnd()#垂直向前滚动，直到出现特定的ui对象d(scrollable=True).scroll.to(text="Security") Watcher（==未懂==）当选择器没有找到匹配项时，可以注册watchers 来执行一些操作。 注册 Watcher 当选择器找不到匹配项时，uiautomator2将运行所有注册的watchers. 当条件匹配时单击目标 d.watcher("AUTO_FC_WHEN_ANR").when(text="ANR").when(text="Wait") \ .click(text="Force Close")# d.watcher(name) ## 创建一个新的名为watcher的程序。# .when(condition) ## 监视程序的用户选择条件。# .click(target) ## 对目标UiSelector执行单击操作 还有一个关于点击的技巧。您可以不带参数地使用click。 d.watcher("ALERT").when(text="OK").click()# 一样d.watcher("ALERT").when(text="OK").click(text="OK") 当条件为真时按下键 d.watcher("AUTO_FC_WHEN_ANR").when(text="ANR").when(text="Wait") \ .press("back", "home")# d.watcher(name) ## 创建一个新的名为watcher的程序# .when(condition) ## 监视程序的用户选择条件# .press(&lt;keyname&gt;, ..., &lt;keyname&gt;.() ## 按顺序按下一个键 检查指定的监视程序是否触发 一个监视程序被触发，这意味着运行了监视程序并匹配了它的所有条件。 d.watcher("watcher_name").triggered# 如果指定的监视程序被触发，则为true，否则为false 删除指定的监视程序 # 删除观察者d.watcher("watcher_name").remove() 列出所有观察者 d.watchers#列出所有注册观察员的名单 检查任何触发的监视程序 d.watchers.triggered# 在任何监视程序触发时为真 重置所有触发观察者 # 重置所有触发的观察者，然后是d.观察者。触发将为false。d.watchers.reset() 删除观察者 # 删除所有注册观察者d.watchers.remove()# 删除指定的监视程序，与d.watcher(“watcher_name”)相同。d.watchers.remove("watcher_name") 强制运行所有的观察者 # 强制运行所有注册的观察者d.watchers.run() 当页面更新时运行所有观察者。 通常可以用来自动点击权限确认框，或者自动安装 d.watcher("OK").when(text="OK").click(text="OK")# 启用自动触发监视程序d.watchers.watched = True# 禁用自动触发监视程序d.watchers.watched = False# 获取当前触发器监视者状态assert d.watchers.watched == False 另外文档还是有很多没有写，推荐直接去看源码init.py 全局设置# 设置每次UI点击后1.5秒的延迟d.click_post_delay = 1.5 # 默认没有延迟# 设置默认元素等待超时(秒)d.wait_timeout = 30.0 # 默认的20.0 UiAutomator中的超时设置(隐藏方法) &gt;&gt; d.jsonrpc.getConfigurator() &#123;'actionAcknowledgmentTimeout': 500, 'keyInjectionDelay': 0, 'scrollAcknowledgmentTimeout': 200, 'waitForIdleTimeout': 0, 'waitForSelectorTimeout': 0&#125;&gt;&gt; d.jsonrpc.setConfigurator(&#123;"waitForIdleTimeout": 100&#125;)&#123;'actionAcknowledgmentTimeout': 500, 'keyInjectionDelay': 0, 'scrollAcknowledgmentTimeout': 200, 'waitForIdleTimeout': 100, 'waitForSelectorTimeout': 0&#125; 为了防止客户端程序响应超时，waitForIdleTimeout和waitForSelectorTimeout目前已改为0 Refs: Google uiautomator Configurator Input method这种方法通常用于不知道控件的情况下的输入。第一步需要切换输入法，然后发送adb广播命令，具体使用方法如下 d.set_fastinput_ime(True) # 切换成FastInputIME输入法d.send_keys("你好123abcEFG") # adb广播输入d.clear_text() # 清除输入框所有内容(Require android-uiautomator.apk version &gt;= 1.0.7)d.set_fastinput_ime(False) # 切换成正常的输入法d.send_action("search") # 模拟输入法的搜索 send_action 说明 该函数可以使用的参数有 go search send next done previous 什么时候该使用这个函数呢？ 有些时候在EditText中输入完内容之后，调用press(&quot;search&quot;) or press(&quot;enter&quot;)发现并没有什么反应。这个时候就需要send_action函数了，这里用到了只有输入法才能用的IME_ACTION_CODE。send_action先broadcast命令发送给输入法操作IME_ACTION_CODE，由输入法完成后续跟EditText的通信。（原理我不太清楚，有了解的，提issue告诉我) Toast 展示Toast d.toast.show("Hello world")d.toast.show("Hello world", 1.0) # 显示为1.0，默认为1.0 获取 Toast # [参数]# 5.0: 最大等待超时。默认的10.0# 缓存时间10.0s。如果最近10s已经出现toast，则返回缓存toast。默认10.0(将来可能会有变化)# 如果最终没有toast，返回"default message"。默认没有d.toast.get_message(5.0, 10.0, "default message")# 常见的使用assert "Short message" in d.toast.get_message(5.0, default="")#清楚缓存toastd.toast.reset()# Now d.toast.get_message(0) is None XPath 例如: 其中一个节点的内容 &lt;android.widget.TextView index="2" text="05:19" resource-id="com.netease.cloudmusic:id/qf" package="com.netease.cloudmusic" content-desc="" checkable="false" checked="false" clickable="false" enabled="true" focusable="false" focused="false" scrollable="false" long-clickable="false" password="false" selected="false" visible-to-user="true" bounds="[957,1602][1020,1636]" /&gt; xpath定位和使用方法 有些属性的名字有修改需要注意 description -&gt; content-descresourceId -&gt; resource-id 常见用法 # 等待10sd.xpath("//android.widget.TextView").wait(10.0)# 找到并单击d.xpath("//*[@content-desc='分享']").click()# 检查是否存在if d.xpath("//android.widget.TextView[contains(@text, 'Se')]").exists: print("exists")# 获取所有文本视图文本、属性和中心点for elem in d.xpath("//android.widget.TextView").all(): print("Text:", elem.text)#获取视图文本for elem in d.xpath("//android.widget.TextView").all(): print("Attrib:", elem.attrib)#获取属性和中心点#返回: (100, 200)for elem in d.xpath("//android.widget.TextView").all(): print("Position:", elem.center()) 其他XPath常见用法 # 所有元素//*# resource-id包含login字符//*[contains(@resource-id, 'login')]# 按钮包含账号或帐号//android.widget.Button[contains(@text, '账号') or contains(@text, '帐号')]# 所有ImageView中的第二个(//android.widget.ImageView)[2]# 所有ImageView中的最后一个(//android.widget.ImageView)[last()]# className包含ImageView//*[contains(name(), "ImageView")]]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础语句总结]]></title>
    <url>%2F2019%2F05%2F20%2FSQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言：SQL 是用于访问和处理数据库的标准的计算机语言。 什么是 SQL？SQL 指结构化查询语言SQL 使我们有能力访问数据库SQL 是一种 ANSI 的标准计算机语言编者注：ANSI，美国国家标准化组织 #显示数据库show databases;#判断是否存在数据库test_mysql,有的话先删除drop database if exists test_mysql;#创建数据库create database test_mysql;#删除数据库drop database test_mysql;#使用该数据库use test_mysql;#显示数据库中的表show tables;#先判断表是否存在,存在先删除drop table if exists student;#创建表create table student(id int auto_increment primary key,name varchar(50),sex varchar(20),date varchar(50),)default charset=utf8;#删除表drop table student;#查看表的结构describe student; #可以简写为desc student;#插入数据insert into student values(null,'test','2018-10-2');#查询表中的数据select * from student;select id,name from student;#修改某一条数据update student set name='jack' where id=4;#删除数据delete from student where id=8;# and 且select * from student where date&gt;'2018-1-2' and date&lt;'2018-12-1';# or 或select * from student where date&lt;'2018-11-2' or date&gt;'2018-12-1';#betweenselect * from student where date between '2018-1-2' and '2018-12-1';#in 查询制定集合内的数据select * from student where id in (1,3,5);#排序 asc 升序 desc 降序select * from student order by id asc;#分组查询 #聚合函数select max(id),name,sex from student group by sex;select min(date) from student;select avg(id) as 'Avg' from student;select count(*) from student; #统计表中总数select count(sex) from student; #统计表中性别总数 若有一条数据中sex为空的话,就不予以统计~select sum(id) from student;#查询第i条以后到第j条的数据(不包括第i条)select * from student limit 2,5; #显示3-5条数据#修改数据update student set name='test' where id=2;update student set name='花花',sex='女' where id=2delete from student where id=2;#修改表的名字#格式:alter table tbl_name rename to new_namealter table student rename to test_1;#向表中增加一个字段(列)#格式:alter table tablename add columnname type;/alter table tablename add(columnname type);alter table student add age varchar(20) set default '1'; #set default 设置默认值#修改表中某个字段的名字alter table tablename change columnname newcolumnname type; #修改一个表的字段名alter table student change name test_name varchar(50);#去掉表中字段age的默认值alter table student alter age drop default;#去掉表中字段agealter table student drop column age;#删除表中主键alter table student drop primary key;#表中增加主键#alter table add primary key (column1,column2,....,column)alter table student add primary key (student_id);#用文本方式将数据装入数据库表中（例如D:/mysql.txt）load data local infile "D:/mysql.txt" into table MYTABLE;#导入.sql文件命令（例如D:/mysql.sql）source d:/mysql.sql; #或者 /. d:/mysql.sql;]]></content>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew]]></title>
    <url>%2F2019%2F05%2F20%2FHomebrew%2F</url>
    <content type="text"><![CDATA[什么是Homebrew？Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 官方网站：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew —— OS X 不可或缺的套件管理器。 安装Homebrew#安装/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"`#验证是否安装成功brew doctor#查看brew版本brew -v#查看brew帮助文档brew –help#更新Homebrewbrew update 使用Homebrew#安装包brew install &lt;packageName&gt;#卸载软件brew uninstall &lt;packageName&gt;#搜索软件brew search &lt;packageName&gt;#查看已安装软件列表brew list#更新包brew upgrade # 更新全部包brew upgrade $FORMULA # 更新指定包brew outdated # 查看可更新的包#清理旧版本和缓存文件brew cleanup # 清理所有包的旧版本brew cleanup $FORMULA # 清理指定包的旧版本brew cleanup -n # 查看可清理的旧版本包，不执行实际操作#查看包信息brew info &lt;packageName&gt;]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[item2常用快捷键]]></title>
    <url>%2F2019%2F05%2F20%2Fitem2%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[标签 新建标签：command + t 关闭标签：command + w 切换标签：command + 数字 command + 左右方向键 切换全屏：command + enter 查找：command + f 分屏 垂直分屏：command + d 水平分屏：command + shift + d 切换屏幕：command + option + 方向键 command + [ 或 command + ] 查看历史命令：command + ; 查看剪贴板历史：command + shift + h 其他 清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 前进后退：ctrl + f/b (相当于左右方向键) 上一条命令：ctrl + p 搜索命令历史：ctrl + r 删除当前光标的字符：ctrl + d 删除光标之前的字符：ctrl + h 删除光标之前的单词：ctrl + w 删除到文本末尾：ctrl + k 交换光标处文本：ctrl + t 清屏1：command + r 清屏2：ctrl + l 自带有哪些很实用的功能/快捷键 ⌘ + 数字在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴，这个很实用 ⌘ + f 所查找的内容会被自动复制 ⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏 ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 ctrl + u 清空当前行，无论光标在什么位置 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 ⌘ + shift + h 会列出剪切板历史 可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 我常用的一些快捷键 ⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了 ⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e ⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f / ⌥b，看个人习惯了 设置方法如下当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合 C+a / C+e 这个几乎在哪都可以使用 C+p / !! 上一条命令 C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但iterm中是删掉整行) C+w A+d 从光标处删至字首/尾 C+h C+d 删掉光标前后的自负 C+y 粘贴至光标后 C+r 搜索命令历史，这个较常用 选择喜欢的配色方案。在Preferences-&gt;Profiles-&gt;Colors的load presets可以选择某个配色方案。也可以自己下载。在网站http://iterm2colorschemes.com/，几乎可以找到所有可用的配色方案。 选中即复制iterm2有2种好用的选中即复制模式。 一种是用鼠标，在iterm2中，选中某个路径或者某个词汇，那么，iterm2就自动复制了。 另一种是无鼠标模式，command+f,弹出iterm2的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入tab，查找窗口将自动变化内容，并将其复制。如果输入的是shift+tab，则自动将查找内容的左边选中并复制。 屏幕切割 command+d：垂直分割； command+shift+d：水平分割 自动完成输入打头几个字母，然后输入command+; iterm2将自动列出之前输入过的类似命令。 剪切历史输入command+shift+h，iterm2将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在Preferences &gt; General &gt; Save copy/paste history to disk.中设置。 全屏切换command+enter进入与返回全屏模式 Exposé所有Tabcommand+option+e,并且可以搜索]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令总结]]></title>
    <url>%2F2019%2F05%2F20%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[系统信息arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 文件和目录cd /home 进入 '/ home' 目录cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 'dir1' 的目录mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 'file1' 的文件rmdir dir1 删除一个叫做 'dir1' 的目录rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/ * . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) 文件搜索find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 'user1' 的文件和目录 find /home/user1 -name \*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name \*.rpm -exec chmod 755 '&#123;&#125;' \; 搜索以 '.rpm' 结尾的文件并定义其权限 find / -xdev -name \*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备 locate \*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件 bzip2 file1 压缩一个叫做 'file1' 的文件 gunzip file1.gz 解压一个叫做 'file1.gz'的文件 gzip file1 压缩一个叫做 'file1'的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包 rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1' rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 'more' 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 网络配置管理ifconfig ‐a //查ip信息 ping ‐C 4 192.168.xxx.xxx //ping4次setup //配置ip、防火墙、服务等，需要root用户执行ifconfig eth0 192.168.1.100 netmask 255.255.255.0 //临时设置ip vi /etc/sysconfig/network‐scrippts/ifcfg‐eth0 //永久设置ip dhclient eth0 //启用dhcp模式service network restart //重启网络服务[stop、start]service iptables stop //关闭防火墙，[start]开启，[status]查看状态hostname //查看主机名netstat ‐an //查看所有端口lsof ‐i :8080 //查看具体端口号运行的程序12. nmap 10.1.252.121 //扫描端口 VI底行模式:set nu //显示行号:set nonu //不显示行号 :n //跳转到指的第n行:w file //另存为:n1,n2 s/string1/string2/g //从n1行到n2行将string1替换为string2:%s/string1/string2/g //将所有行string1替换为string2，%代表所有行，g表示所有string1字:%s+/usr/local/bin+/usr/bin+g //替换的字符中含有“/”时，用+来代替/:wq //保存并退出:q! //强制退出，不保存 VI命令模式G //到末行gg //到首行dd //删除行u //撤销yy //复制一行nyy //复制n行 p //粘贴 nmon性能测试监控工具1、./ nmon -f -t -s 30 -c 180 -f：按标准格式输出文件：&lt;hostname&gt;_YYYYMMDD_HHMM.nmon； -t：输出中包括占用率较高的进程； -s 30：每30秒进行一次数据采集 -c 180：一共采集180次2、sort -A test.nmon &gt; test.csv //通过sort命令可以将nmon结果文件转换为csv文件 其他ctrl+u //从光标处向前批量删除命令串 ctrl+k //从光标处向后批量删除命令串 ctrl+a //将光标移动到最前ctrl+e //将光标移动到最后rz //运行该命令会弹出一个文件选择窗口，从本地选择文件上传到服务器sz file //将选定的文件file发送到本地机器vifm、ranger //图形的文件管理操作dos2unix file //将DOS格式的文本文件转换成UNIX格式]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
